## 题目分析
给定一个非负的数组和一个整数`k`，写一个函数检查是否存在长度至少是`2`的连续子数组，使得该子数组的总和是`k`的整数倍。  
```cpp
例一：
输入: [23, 2, 4, 6, 7],  k=6
输出: True
分析: 因为 [2, 4] 是一个长度为 2，总和为 6 的连续子数组。

例二：
输入: [23, 2, 6, 4, 7],  k=6
输出: True
分析: 因为 [23, 2, 6, 4, 7] 是一个长度为 5，总和为 42 的连续子数组。
```
限制条件：  
1. 数组长度不会超过`10000`；
2. 数组内所有数字的总和可以由`32`位有符号整数表示。

## 题解
### 解题思路（1）
题目要求子数组必须是连续的且长度大于`1`，比较直接的想法是检查所有的长度大于`1`的连续子数组，直到找到满足条件的子数组返回`true`，或者未找到返回`false`。  
比如长度为`5`的数组`[23, 2, 6, 4, 7]`：  
- 第一个子数组`[23, 2]`，不满足；子数组大小加一`[23, 2, 6]`，不满足；下一个子数组`[23, 2, 6, 4]`，不满足；下一个子数组`[23, 2, 6, 4, 7]`，满足,返回`true`。
- 如果上面没找到满足条件的子数组，下一轮检查从`[2,6]`开始，在下一轮从`[6,4]`，依次进行。

**算法复杂度**  
数组的长度为`n`，由于在子数组大小加一时，`子数组的总和 = 之前子数组的总和 + 当前数字`，因此每一轮的检查的时间复杂度最大为`O(n)`。  
一共有`n-1`轮检查，因此总体的时间复杂度为`O(n^2)`，空间复杂度为`O(1)`。

### 解题思路（2）
具体实现在`solution.cpp`中。  
在数学上，连续子数组的总和是整数`k`的整数倍，等同于连续子数组的总和能被整数`k`整除。  
给定数组`[a1,a2,a3,...,an]`，整数`k`，检查是否存在长度至少是`2`的连续子数组，使得该子数组的总和能被整数`k`整除，即：  
- 是否存在`i`和`j`，`j - i > 1`，使得`(ai + ai+1 + ··· + aj)%k == 0`。

**约定：**前`m`个数数字的总和为 `sum[m]`  
数论中有如下等式：  
- `(a +/- b)%k = (a%k +/- b)%k = (a%k +/- b%k)%k`。

推论：若`(ai + ai+1 + ··· + aj)%k == 0`，即`(sum[j] - sum[i-1])%k = (sum[j]%k - sum[i-1]%k)%k == 0`，即 `sum[i-1]%k == sum[j]%k`。  
上面的推论说明，如果数组中的某一连续子数组`[ai,...,aj]`总和可以被`k`整除，那么数组前`i-1`个数字的总和与数组前`j`个数字的总和模`k`同余。  
结论：若数组中存在满足条件的连续子数组，那么一定存在`i`和`j`，`j - i > 1`，使得`sum[i-1]%k == sum[j]%k`。  

根据以上的结论，我们只需要记录下数组前`m(1<=m<=n)`个数字总和模`k`的余数即可，若出现相同的余数并且连续子数组长度大于`1`，返回`true`。

上面数论中的结论，允许我们这样计算余数：  
- 假设数组前`m`个数字的和的余数是`mod[m] = (a1 + ··· + am)%k`，那么数组前`m+1`个数字的和的余数是`mod[m+1] = (a1 + ··· + am + am+1)%k = [(a1 + ··· + am)%k + am+1]%k = (mod[m] + am+1)%k`。

现在，我们既找到了计算数组前`m(1<=m<=n)`个数字总和模`k`的余数的方法，也找到了判断连续子数组是否满足条件的判定条件。

**算法复杂度**   
从计算数组前`1`个数字总和的余数到计算数组前`n`个数字总和的余数，只需要遍历一次数组，时间复杂度是`O(n)`。  
如果我们使用`hash`表记录数组前`m(1<=m<=n)`个数字总和模`k`的余数，每次查询的时间复杂度是`O(1)`；  
因此总体的时间复杂度是`O(n)`，空间复杂度是`O(n)`。

### 例题
输入: `[23, 2, 6, 4, 7],  k=6`。  
数组前缀和的余数为 `prefixModSum=0`；使用`unordered_map<int, int> modSum`记录不同的数组前缀和的余数和位置的对应关系,例如前`1`个数字的前缀和的余数是`5`，则`modSum[5]=1`，前`2`个数字的前缀和的余数是`1`，则`modSum[1]=2`。  
- `modSum = [], prefixModSum = 0`；  
当前数字`23`，则`prefixModSum = (prefixModSum + 23)%6 = 5`，`modSum[5]=1`；  
- `modSum = [5->1], prefixModSum = 5`；  
当前数字`2`，则`prefixModSum = (prefixModSum + 2)%6 = 1`，`modSum[1]=2`；  
- `modSum = [5->1, 1->2], prefixModSum = 1`；  
当前数字`6`，则`prefixModSum = (prefixModSum + 6)%6 = 1`，`sum[3]%k == sum[2]%k`，但是连续子数组为`[6]`，大小为`1`，不满足条件（不需要更新`modSum[1]=3`，如果更新可能会漏掉满足条件的连续子数组）；  
- `modSum = [5->1, 1->2], prefixModSum = 1`；  
当前数字`4`，则`prefixModSum = (prefixModSum + 4)%6 = 5`，`sum[4]%k == sum[1]%k`，连续子数组`[2, 6, 4]`满足条件，返回`true`；  

输出: `true`。

