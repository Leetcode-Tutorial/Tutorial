## 题目分析：

在一张图中，N个点之间通过M条单向边连接。已知起点以及点之间的连接关系，要求给出一条路线，覆盖每一条单向边，每条单向边仅可被使用一次。若有多解则要求由地名组合成的路线满足字典序最小。题目确保有解。

### 解题思路（1）:
常规的深度优先级搜索。  
对于每个点建立一个容器以存储其出边可到达的另一个点。  
而后对其进行排序，按字典序从小到大依次排列。
进行搜索时，i指针在容器中往后走，遇到第一个未被使用的出边，则将其进行标记，尝试将边所指向的点作为路径上的下一个点，进行下一步搜索，直到当前点已无未被使用出边为止。  
之后对当前图进行一遍检查，检查是否每条边都已经被遍历了一遍。  
若不满足要求则进行回溯，将当前i指针所指向的边恢复为未被使用的状态，继续向后走，寻找下一个可能使用的边。  
整个搜索树的深度为`total_edge_num`，时间复杂度受图的影响较大，难以估计。
### 解题思路（2）:
由于图必然有解的特殊性，因此整个图满足下述性质  
<li> 入度和出度不相等的点只有两个，它们是起点与终点
<li> 入度和出度相等的点是路径当中的普通过渡点  

![Markdown](http://p1.bpimg.com/1949/5dfb17b442ab1f06.png)  

参见上图，若红点为起点，黄点为终点，第一次dfs时我们得到下图中被红色突出标记的路线  

![Markdown](http://chuantu.biz/t5/48/1488452647x3525231103.png)  
可看到，残余图中由数个完整的欧拉环组成，只要在原来的路线中插入数个欧拉环的遍历路线便可以得到合法的路线。  
而欧拉环只要一直dfs下去便可以得到完整的路径。  
综上所述，首先从起点开始做dfs，每次都选择下一个城市名最小的单向边，寻找一条到达终点的路径，而后反向记录路径，路径中的点若有其他出边，说明在残余图中该点包含在一个欧拉环内，通过dfs将欧拉环遍历顺序反向记录，插入到原来路径之中。  
在每一个点以小根堆记录出边，初始化的时间复杂度为O(`MlogM`)，dfs过程之中的时间复杂度为(`M` * `log M`)，总体复杂度为O(`M`*`log M`)
