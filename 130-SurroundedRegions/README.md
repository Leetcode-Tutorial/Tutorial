### 题意
**中文描述**  
一个二维矩阵由 `'X'` 和 `'O'`（字母 O） 组成，占领被 `'X'` 包围的 `'O'` 所在区域。  
通过将被 `'X'` 包围的 `'O'` 变成 `'X'`。  
举个例子，
```cpp
X X X X
X O O X
X X O X
X O X X
```
占领之后，二维矩阵应该是以下这样
```cpp
X X X X
X X X X
X X X X
X O X X
```

### 题解
#### 解题思路（1）
具体实现在 `solution1.cpp`。  
解决这个问题的关键点：确定每个 `'O'` 是否被 `'X'` 包围。  
如果一个 `'O'` 被 `'X'` 包围，它一定不能通过它周围的 `'O'` 扩展到边界，举个例子：
```cpp
X X X X
X O O X		这一行的两个 'O'，都不能扩展到边界。
X X O X		这一行的 'O' 不能扩展到边界。
X O X X		这一行的 'O' 可以通过它下方的 'O' 扩展到边界。
X O X X		这一行的 'O' 在边界上。
```
上面论述的另一种表达是：如果一个 `'O'` 没有被 `'X'` 包围，它一定可以通过它周围的 `'O'` 扩展到边界。  
上面的结论给了我们一种解题思路：  
- 从当前的 `'O'` 开始，通过它周围的 `'O'` 向外扩展；
- 如果可以扩展到边界，说明在扩展过程中碰到的所有的 `'O'` 都可以扩展到边界，也就是说这些 `'O'` 都没有被包围；
- 如果不能扩展到边界，说明在扩展过程中碰到的所有的 `'O'` 都不可以扩展到边界，也就是说这些 `'O'` 都被包围了，把这些 `'O'` 都变为 `'X'`。  

**使用宽度优先遍历实现扩展过程**  
我们可以使用宽度优先遍历向外扩展，在扩展的过程中把碰到的所有 `'O'` 都存起来。  
通过队列结构可以实现宽度优先遍历，队列 `pos_queue< pair<row,col> >` 中的内容是接下来要遍历的 `'O'` 的位置。  
**宽度优先遍历的算法流程：**  
置`可以到达边界标志位`为 `FALSE`，将开始的 `'O'` 的位置加入队列，并将原矩阵中该位置的 `'O'` 变为 'E'。  
为什么要把碰到的 `'O'` 变为  `'E'`：标记为已遍历，避免死循环。  
- 1.如果队列为空，跳到第 `4` 步，否则继续；
- 2.从队列的首部取出一个 `'O'` 的位置，如果它位于边界，置`可以到达边界标志位`为 `TRUE`；
- 3.从当前的 `'O'` 继续向上下左右扩展，如果某个方向有相邻的 `'O'`，把相邻的 `'O'` 的位置放入队列，将原矩阵中该位置的 `'O'` 变为 'E'，返回第 `1` 步。
- 4.若 `可以到达边界标志位` 为 `FALSE`，说明所有经过的 `'O'` 都被包围了，把它们都变成 `'X'`。

**算法复杂度**  
一行一行的从左到右扫描二维矩阵，遇到 `'O'` 执行上面所说的宽度优先遍历。  
由于我们使用 `'E'` 这个字符把遍历过的 `'O'` 标记为已遍历过，在扫描之后还要把所有的 `'E'` 都变成  `'O'` ，所以二维矩阵中的每一个字符只被遍历了 `2` 次。  
因此时间复杂度是 `O(m * n)`，`m` 是二维矩阵第一维大小，`n` 是二维矩阵第二维大小。  
在使用宽度优先遍历向外扩展时，在扩展的过程中要把碰到的所有 `'O'` 都存起来，因此空间复杂度最大（二维矩阵全是 `'O'`）是 `O(m * n)`。

#### 解题思路（2）
具体实现在 `solution2.cpp`。  
我们还可以对之前的方法进行一些改进。  
我们现在已经知道: 如果一个 `'O'` 没有被 `'X'` 包围，它一定可以通过它周围的 `'O'` 扩展到边界。  
反过来说，如果一个 `'O'` 没有被 `'X'` 包围，它一定可以被某个边界的 `'O'` 扩展到。  
这样的话，我们可以只从边界的 `'O'` 开始宽度优先搜索，同样的把已遍历过的 `'O'` 标记为 `'E'`。  
**算法复杂度**  
算法的时间和空间复杂度和上一个方法一样。  

#### 实例
我以第二种方法走一下算法的流程（为了明显，把 `'E'` 变成 `'#'`）：  
二维矩阵 `board[5][5]`：
```cpp
X X X X X
X O O X X
X X X O X
X O O O O
X O X X X
```
从边界找到一个 `'O'`，`board[3][4]`，队列 `queue=[]`,左侧为队首，右侧为队尾：  
- 把当前的 `'O'` 的位置 `(3,4)` 加入队列，并将原矩阵中该位置的 `'O'` 变为 `'#'`，从该位置开始宽度优先遍历。  
```cpp
queue = [(3,4)]
X X X X X
X O O X X
X X X O X
X O O O #
X O X X X
```
- 队列不空，从队首取出位置 `(3,4)`,该位置左侧有相邻的 `'O'`；把相邻的 `'O'` 的位置 `(3,3)` 加入队列，并将原矩阵中该位置的 `'O'` 变为 `'#'`。  
```cpp
queue = [(3,3)]
X X X X X
X O O X X
X X X O X
X O O # #
X O X X X
```
- 队列不空，从队首取出位置 `(3,3)`,该位置左侧和上面有相邻的 `'O'`；把相邻的 `'O'` 的位置 `(3,2) 和 (2,3)` 加入队列，并将原矩阵中该位置的 `'O'` 变为 `'#'`。  
```cpp
queue = [(3,2), (2,3)]
X X X X X
X O O X X
X X X # X
X O # # #
X O X X X
```
- 队列不空，从队首取出位置 `(3,2)`,该位置左侧有相邻的 `'O'`；把相邻的 `'O'` 的位置 `(3,1)` 加入队列，并将原矩阵中该位置的 `'O'` 变为 `'#'`。  
```cpp
queue = [(2,3), (3,1)]
X X X X X
X O O X X
X X X # X
X # # # #
X O X X X
```
- 队列不空，从队首取出位置 `(2,3)`,该位置四周没有相邻的 `'O'`。  
```cpp
queue = [(3,1)]
X X X X X
X O O X X
X X X # X
X # # # #
X O X X X
```
- 队列不空，从队首取出位置 `(3,1)`,该位置下方有相邻的 `'O'`；把相邻的 `'O'` 的位置 `(4,1)` 加入队列，并将原矩阵中该位置的 `'O'` 变为 `'#'`。  
```cpp
queue = [(4,1)]
X X X X X
X O O X X
X X X # X
X # # # #
X # X X X
```
- 队列不空，从队首取出位置 `(4,1)`,该位置四周没有相邻的 `'O'`。  
```cpp
queue = []
X X X X X
X O O X X
X X X # X
X # # # #
X # X X X
```
- 队列为空，宽度优先遍历终止。

继续从边界寻找  `'O'`，发现没有了。  
这时，把二维矩阵中所有的 `'O'` 变为  `'X'`,所有的 `'#'` 变为 `'O'`。  
```cpp
X X X X X
X X X X X
X X X O X
X O O O O
X O X X X
```