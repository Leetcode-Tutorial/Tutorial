### 题意
**中文描述**  
给定一棵二叉树，返回树的节点值的中序遍历.  
注意: 不能使用递归的算法.  
**题意分析**  
使用非递归的算法进行二叉树的中序遍历.  

### 题解
**算法及复杂度(3 ms)**  
本题如果使用递归的算法，那么中序遍历的核心代码只需要三行就可以完成，分别是: 递归左子树；访问本节点；递归右子树.  
本题需要使用非递归的算法进行求解.其实可以通过使用栈进行实现递归的过程.具体算法描述如下:  
```
根节点root入栈
if(root == NULL) return ;
while(栈不为空)
    取栈顶元素，判左儿子节点是否访问或为空：如果此儿子节点不为空且没访问，就入栈；否则，访问原节点，标记原节点为访问，并且若右儿子节点不为空且未访问就入栈.
end
return 访问序列
```  
其实就是利用栈和访问标记实现递归相同的功能.  
这里唯一的技巧就是根据已经存在的树另外建立了一棵树用于记录某节点进行了访问.  
***时间复杂度:*** O(n). n表示树中节点的个数，经过一次遍历就可以得到结果.  
***代码参见本文件夹下solution.cpp***  

### 算法正确性
**正确性证明**  
本算法的正确性等同于递归解法的正确性，递归解法的正确性是从定义来的.  
**举个例子**  
```
//输入数据，树的形式参考原题中例子，标记树为visitTree
Tree = [1,null,2,3], visitTree = NULL

//根节点入栈st
st = [1]

//取栈顶元素为值为1的节点，左儿子节点为空，则访问原节点并出栈，并判断右儿子节点入栈
visitTree = [true], st = [2], ans = [1]

//取栈顶元素为值为2的节点，左儿子节点不为空，左儿子节点入栈
visitTree = [true, false], st = [2, 3]

//取栈顶元素为值为3的节点，左儿子节点为空，则访问原节点并出栈，并判断右儿子节点为空不入栈
visitTree = [true, false, true], st = [2], ans = [1, 3]

//取栈顶元素为值为2的节点，左儿子节点已访问，则访问原节点并出栈，并判断右儿子节点为空不入栈
visitTree = [true, true, true], st = [], ans = [1, 3, 2]

//返回结果ans = [1, 3, 2]
```
