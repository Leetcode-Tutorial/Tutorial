### 题意
**中文描述**
给定一串数字，返回这些数字可以代表的所有的英文字母组合.  
其中，数字到字母的映射就是手机按钮的中数字到字母的映射.  
举个例子:  
```
Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```  
注意: 可能样例给出的是按照字典顺序的，但是你的答案序列可以是任意顺序的.  
**题意分析**  
使用回溯法搜索尽所有可能的次序.  

### 题解
**算法及复杂度(3 ms)**  
题目要求使用回溯法.回溯法的过程十分简单，就是按照要求的次序进行搜索（通常是深度优先搜索），得到一个答案或者无法继续搜索时则进行回溯，之后继续搜索，直到穷尽所有可能的要求的次序.  
本题采用递归的方法，搜索过程中记录本次数字代表的字母次序，过程采用深度优先搜索的方法，每层进行一个数字代表的不同字母的尝试，先尝试一个字母，然后递归这个字母被选定情况下的所有搜索，之后把这个字母换成这个数字代表的下一个字母，直到搜索完这个字母代表的所有字母，然后返回上一层.  
***时间复杂度:*** 最差为O(4^n). 算法的过程实质上等价于枚举，最坏的情况下每个数字代表4个字母，一共有n个数字.  
***代码参见本文件夹下solution.cpp***  

### 算法正确性
**正确性证明**  
搜索过程等价于枚举.  
**举个例子**  
```
// 输入字符串, n = 2
digits = "23"

// 其中2映射为字母"abc", 3映射为字母"def"，初始状态如下
temp = "", result = []

// temp长度不等于n，则abc分别进入temp，在temp中追加2，进入下一层
temp = "a", result = []

// temp长度不等于n，则def分别进入temp，在temp中追加d，进入下一层
temp = "ad", result = []

// temp长度等于n = 2，在result中追加temp，之后返回上一层
temp = "ad", result = ["ad"]

// temp删除最后一个元素，进行下一次循环，在temp中追加e，进入下一层
temp = "ae",  result = ["ad"]

// temp长度等于n = 2，在result中追加temp，之后返回上一层
temp = "ae", result = ["ad", "ae"]

// 之后过程类似，直到搜索完所有的顺序，最后返回result
```  
