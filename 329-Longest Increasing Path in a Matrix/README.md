## 题目分析：
给你一个大小为n*m的矩阵，每个单元都有一个数字。现要求输出最长的数值严格上升的一条路径的长度。  
从一点出发，只可上下左右地移动。

### 解题思路（1）:
最为常规的解法是，从每一点出发，然后向四个方向去寻找下一个可以移动的单元，即数值满足较当前单元大的条件，直到不可移动为止。这种情况下每个结点将会被多次访问，时间复杂度为`O(n^2 * m^2)`  
### 解题思路（2）:  
在解法1中，我们将会对一个单元进行多次搜索，而对当个单元而言。每次搜索所建立的**搜索树都是相同的**，而导致往后的搜索实质上是冗余的。
因此考虑新开一数组`f[x][y]`来记录，对坐标为`(x,y)`的点进行搜索，得到的最大的路径长度。该值另可解释为**以`(x,y)`作为序列中第一个数值，可得到的最长上升序列的长度**。  
这种做法可保证对每个单元仅进行一次搜索，时间复杂度为`O(n*m)`
### 算法正确性:   
由于从一单元可移动的下一点要严格大于当前单元，因此全局的搜索形成了一种拓扑结构，可保证最优情况下对每个单元进行一次搜索计算出全局最优值的正确性。而本题的数据时静态的，使从一点向下的搜索树恒定不变，使记忆化成为可能。  
下面举一个例子以帮助理解算法:  
  [9,9,4]  
  [6,6,8]  
  [2,1,1]  
**(1,1)**：无可移动结点，`f[1][1]=1`  
**(1,2)**：无可移动结点，`f[1][2]=1`  
**(1,3)**: 可移动至(1,2)，(1,2)的值事先已被计算出来，因此若走(1,2)则最长路径长度为2;可移动至(2,3)，(2,3)无可移动点，f[2][3]=1，返回(1,3),因此若走(2,3)，最长路径长度为2；  
**(2,1)**: 可移动至(1,1)，(1,1)的值事先已被计算出来，因此若走(1,1)则最长路径长度为2;  
**(2,2)**: 可移动至(1,2)，(1,2)的值事先已被计算出来，因此若走(1,2)则最长路径长度为2;可移动至(2,3)，(2,3)的值事先已被计算出来，因此若走(2,3)则最长路径长度为2;  
**(2,3)**：已被计算，最长路径长度为1;  
**(3,1)**: 可移动至(2,1)，(2,1)的值事先已被计算出来，因此若走(2,1)则最长路径长度为3;  
**(3,2)**: 可移动至(3,1)，(3,1)的值事先已被计算出来，因此若走(3,1)则最长路径长度为4;   可移动至(2,2)，(2,2)的值事先已被计算出来，因此若走(2,2)则最长路径长度为3;  
**(3,3)**: 可移动至(2,3)，(2,3)的值事先已被计算出来，因此若走(2,3)则最长路径长度为2;
