## 题目分析：
给你一个大小为n*m的矩阵，每个单元都有一个数字。现要求输出最长的数值严格上升的一条路径的长度。  
从一点出发，只可上下左右地移动。

### 解题思路（1）:
最为常规的解法是，从每一点出发，然后向四个方向去寻找下一个可以移动的单元，即数值满足较当前单元大的条件，直到不可移动为止。这种情况下每个结点将会被多次访问，时间复杂度为`O(n^2 * m*2)`  
### 解题思路（2）:  
在解法1中，我们将会对一个单元进行多次搜索，而对当个单元而言。每次搜索所建立的**搜索树都是相同的**，而导致往后的搜索实质上是冗余的。
因此考虑新开一数组`f[x][y]`来记录，对坐标为`(x,y)`的点进行搜索，得到的最大的路径长度。该值另可解释为**以`(x,y)`作为序列中第一个数值，可得到的最长上升序列的长度**。  
这种做法可保证对每个单元仅进行一次搜索，时间复杂度为`O(n*m)`
### 算法正确性:
下面举一个例子以帮助理解算法:  
  [9,9,4]  
  [6,6,8]  
  [2,1,1]  
**(1,1)**：无可移动结点，`f[1][1]=1`  
**(1,2)**：无可移动结点，`f[1][2]=1`  
**(1,3)**: 可移动至(1,2)，(1,2)的值事先已被计算出来，因此若走(1,2)则最长路径长度为2;可移动至(2,3)，(2,3)无可移动点，f[2][3]=1，返回(1,3),因此若走(2,3)，最长路径长度为2；  
**(2,1)**: 可移动至(1,1)，(1,1)的值事先已被计算出来，因此若走(1,1)则最长路径长度为2;  
**(2,2)**: 可移动至(1,2)，(1,2)的值事先已被计算出来，因此若走(1,2)则最长路径长度为2;可移动至(2,3)，(2,3)的值事先已被计算出来，因此若走(2,3)则最长路径长度为2;  
**(2,3)**：已被计算，最长路径长度为1;
**(3,1)**: 可移动至(2,1)，(2,1)的值事先已被计算出来，因此若走(2,1)则最长路径长度为3;  
**(3,2)**: 可移动至(3,1)，(3,1)的值事先已被计算出来，因此若走(3,1)则最长路径长度为4; 可移动至(2,2)，(2,2)的值事先已被计算出来，因此若走(2,2)则最长路径长度为3;
**(3,3)**: 可移动至(2,3)，(2,3)的值事先已被计算出来，因此若走(2,3)则最长路径长度为2;
