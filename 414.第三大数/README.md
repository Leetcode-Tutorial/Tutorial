# 题目分析
题意要求我们将一个数组中的第三大的数进行返回。
如果数组中元素少于3个，那么返回最大的那个值。注意，相同元素只算一个。

### 解题思路（1）
我们很容易想到对数组进行逆序排序，然后从头到尾扫，用一个变量count=0进行统计不同的个数，最后发现如果count==3的时候，返回当前dang该值，如果扫描完后，还发现count<3，那么返回排好序数组中的第一个。即可。但是这样的时间复杂度是排序的复杂度0(nlogn)，与题目中要求的0（n）不是太符合，我们必须另想办法！

### 解题思路（2）
我们发现不能对数组进行排序，因为排序中最快的算法就是0（nlogn）级别的。题目要求对数量的统计是不包括相同元素的，那么我们可以联系到set集合的特性，我们只要将元素压入到集合中，经过set特性，保证里面是不相同的。

由于set是自带排序功能，那么我们可以利用这点，在压入set的过程中，一直保持set中元素个数是小于3的，如果一当大于3了，将s.begin()set中的最小元素去除，那么这样下来我最终保留的三个元素就是我们最大的三个元素，返回s.begin()即可，如果最后元素是小于3的话，我们使用迭代器返回当前最大元素即可~由于每次都是在大于3的时候立即进行剔除，set的排序时间复杂度趋近于0(klogn)满足条件。

#### 举个例子说明一下：
假如数组元素为1，2，3，3，5
第一次压入1，set中元素为1，个数为1小于等于3
第二次压入2，set中元素为1，2，个数为2小于等于3
第三次压入3，set中元素为1，2，3，个数为3小于等于3
第四次压入3，set中元素还是1，2，3，因为set中有3了
第5次压入5，set中元素为1，2，3，5，个数大于3，那么将s.begin()=1剔除
剩下2，3，5最终返回s.begin()为2，返回结果