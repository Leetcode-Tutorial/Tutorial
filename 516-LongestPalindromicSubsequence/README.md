## 题目分析
给定一个字符串`s`，找出`s`中最长回文子序列的长度，字符串`s`的最大长度为`1000`。
```cpp
例一：
输入："bbbab"
输出：4
分析：最长回文子序列是"bbbb"。

例一：
输入："cbbd"
输出：2
分析：最长回文子序列是"bb"。
```
## 题解
### 解题思路（1）
题目的要求是子序列，而不是连续子串，如果要枚举所有的子序列，所有子序列的数量是`2^n`，判断每个子序列是不是回文串的时间复杂度是`O(n)`，总体的时间复杂度是`O(n * 2^n)`。  
时间复杂度太高，放弃。

### 解题思路（2）
**约定：**  
1. `s[i...j]`表示字符串`s`中第`i`个字符到第`j`个字符的连续子串；  
2. 字符串`str`的最长回文子序列的长度表示为`maxPal(str)`。  

**证明**：如果一个字符串`str`两端的字符是相同的，那么这两个字符所在的回文子序列一定是字符串`str`中最长的回文子序列。  
- 令`str = s[i...j]`，且`s[i] == s[j]`，`str`的最长回文子序列可能由几种方式构成。
- 第一种：`s[i+1...j-1]`的最长回文子序列加上`s[i]和s[j]`，长度为`option1 = 2 + maxPal(s[i+1...j-1])`。
- 第二种：`s[i...j-1]`的最长回文子序列，长度为`option2 = maxPal(s[i...j-1])`。
- 第三种：`s[i+1...j]`的最长回文子序列，长度为`option3 = maxPal(s[i+1...j])`。
- 对第二种方式进行讨论：  
若`s[i...j-1]`的最长回文子序列不包括`s[i]`，那么`s[i...j-1]`的最长回文子序列的长度为`maxPal(s[i...j-1]) = maxPal(s[i+1...j-1]) < option1`；  
若`s[i...j-1]`的最长回文子序列包括`s[i]`，那么最长回文子序列的最右端一定在`s[i+1...j-1]`中，假设是`s[m](i+1 <= m <= j-1)`。因为`s[i+1..m-1] <= s[i+1...j-1]`，那么`maxPal(s[i...j-1]) = 2 + maxPal(s[i+1...m-1]) <= 2 + maxPal(s[i+1...j-1]) = option1`。  
即`option2 <= option1`。
- 第三种方式与第二种讨论方式相同，`option2 <= option1`。
- `option1`是字符串`str=s[i...j]`的最长回文子序列的长度。

证明完毕。  
有了上述的定理，我们就有了找最长子序列的方法，从字符串`str = s[1...n]`开始：  
`left`表示字符串`str`的最左字符，`right`表示字符串`str`的最右字符。
1. 若`left == right`，返回长度`1`。
2. 若`left > right`，返回长度`0`。
3. 若`str[left] == s[right]`，最长回文子串的长度为`2 + maxPal(str[left+1...right-1])`，令`str = str[left+1...right-1]`，从第`1`步开始求`str`的最长回文子序列的长度，计算`str`的最长回文子序列的长度后，返回长度`2 + maxPal(str[left+1...right-1])`。  
若`str[left] != s[right]`，最长回文子串的长度为`max(maxPal(str[left...right-1], maxPal(str[left+1...right])`，分别令`str = str[left...right-1]`和`str = str[left+1...right]`，从第`1`步开始求`str`的最长回文子序列的长度，计算`str`的最长回文子序列的长度后，返回长度`max(maxPal(str[left...right-1], maxPal(str[left+1...right])`。

上述的算法流程其实是递归，因为递归的过程中会重复计算某些连续子串的最长回文子序列的长度，所以我们在实现的时候可以使用`Memorization`的方法记录已经计算过的连续子串的最长回文子序列的长度。  
具体实现在`solution1.cpp`中。  
**算法复杂度**  
由于使用`Memorization`的方法记录已经计算过的连续子串的最长回文子序列的长度，不会出现重复的计算。  
在最差的情况下（根本不存在回文子串），字符串中的每两个字符都互相比较过，因此时间复杂度为`O(n^2)`，需要`Memorization`二维数组记录已经计算过的连续子串的最长回文子序列的长度，因此空间复杂度也是`O(n^2)`。

### 解题思路（3）
具体实现在`solution2.cpp`中。  
使用`Memorization`的方法，可以看作是动态规划的思想，也可以不使用递归实现动态规划。  
对于字符串`s[i...j]`：  
- 若`s[i] == s[j]`，最长回文子序列的长度为`2 + maxPal(s[i+1...j-1])`；
- 否则，最长回文子序列的长度为`max(maxPal(s[i...j-1]), maxPal(s[i+1...j]))`。  

我们在计算`maxPal(s[i...j])`时，如果`maxPal(s[i+1...j-1])`、`maxPal(s[i...j-1])`和`maxPal(s[i+1...j])`都已经知道了，是不是就可以实现动态规划了。  
要想达到上面的效果，我们要好好的规划一下计算的顺序，动态规划的关键点之一就是确定计算的顺序。  
如下图，我们想要计算`?`处的值，就需要知道`3`个`#`处的值，因此计算的顺序应该是**从下至上，从左至右**。  
```cpp
dp[][]=
[
         j-1  j
     0 0 0    0 0
     0 0 0    0 0
i    0 0 #    ? 0
i+1  0 0 #    # 0
     0 0 0    0 0
]
```
具体的计算顺序（数字代表该处的值是第几个被计算的，`0`表示不计算，`1`表示第一个计算，依次`2, 3...`）：
```cpp
dp[4][4]=
[
0  0  0  0  15
0  0  0  13 14
0  0  10 11 12
0  6  7  8  9
1  2  3  4  5
]
```
可以看到，每一处的数字都比它的左侧、下方和左下方的数字大，说明该处的值是在它的左侧、下方和左下方的值计算之后计算的，符合我们的要求。  
**算法复杂地**  
该算法的时间复杂度和空间复杂度都是`O(n^2)`。  
我们看到计算每一行的时候，我们只会用到当前行和下一行，因此空间可以继续优化，我就不在这里展开了，请读者自行实现。