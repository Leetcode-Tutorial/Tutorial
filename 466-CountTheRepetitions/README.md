## 题目分析：

`S = [s,n]`表示一个字符串S是由s重复n次得到的。如：`["abc",3] = "abcabcabc"`
现在给出`S1 = [s1,n1]`，`S2 = [s2,n2]`，需要求出`S1`在可以删去任意字符的情况下，可能变成`S3 = [S2, M]`，现在要求出`M`的最大值。 

### 解题思路：

先来考虑`s2`，让`s2`在`s1`中进行匹配，若当前`s1`不能让`s2`完全匹配，`s1`最后只让`s2`匹配到`s2[k]`，那么就要在下一个`s1`中从`s2[k+1]`继续进行匹配，考虑这样一种情况，如果第`i`个`s1`要从`s2[k+1]`开始进行匹配，若干次之后，第`j`个`s1`又要从`s2[k+1]`开始进行匹配，那么从`j`之后的匹配一定和之前是一样的，所以`i`到`j`这一段就是一个循环节。我们只要计算出这一个循环节中的`s2`一共出现了`x`次，再计算出`S1`中一共有`y`个循环节，那么S1中这一段重复的部分`s2`出现的次数就是`x*y`。
我们利用`repeat[i]`记录第`i`个`s1`要从`s2[repeat[i]]`开始匹配，利用`cnt[i]`记录到第`i`个`s1`结束为止，`s2`一共出现了多少次。
每次遍历完当前的第`i`个`s1`，就要看当前`repeat[i]`是否与之前的某个`repeat[j]`重复，如果重复，说明出现循环节，然后进行计算返回结果。
`S1`中除了循环的部分，还会有起始和末尾两部分不属于循环节中的，这两个部分需要单独计算。若当前循环节是`i`到`j`，那么还需要计算`[0,i-1]`以及`[j+1,n1]`中`s2`出现的次数。
设找到的循环节是`[i+1,j]`，那么可以计算`S1`中：
重复部分`s2`出现的次数：`(n1 - i) / (j - i) * (cnt[j] - cnt[i])`
起始部分与结尾部分`s2`出现的次数：`cnt[i] + cnt[i + (n1 - i) % (j - i)] - cnt[i]`，也就是`cnt[i + (n1 - i) % (j - i)]`

#### 算法正确性：

上述算法看上去，在最坏情况下可能会需要遍历`n1*(n1-1)/2`次，对于`n1==1e6`的情况下很显然承受不了。但是，该算法复杂度其实没有想象中的那么夸张。
考虑`s2`的长度最长只有`100`，每次`repeat[i]`保存的第`i`个`s1`要从`s2`的第几个字符开始匹配，那么`repeat[i]`的范围显然最大只有`[0,99]`，那么根据抽屉原理，在超过`100`次的访问中一定会存在至少两个相同的`repeat[i]`，所以该算法最多在`100*99/2`次比较就能返回结果，可以满足题目复杂度的要求。

