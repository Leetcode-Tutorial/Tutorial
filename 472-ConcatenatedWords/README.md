## 题目分析：

给出一系列单词，找到所有的合成词并且输出(不用考虑顺序)，合成词就是由至少两个所给出的单词连接而成的词。

### 解题思路：

很显然合成词一定是由比自己短的词组合而成的，所以要先对单词按照长度从小到大排序，对于每个单词单独处理，我们设`dp[i]`表示该单词`[0,i]`这一段是否是合成词，很显然如果`dp[j]`是合成词，而`[j+1,i]`这一段也是出现过的单词，那么`dp[i]`也是合成词。
所以动态转移方程是: `dp[i]=dp[i]||(dp[j]&&(st.count(subtr[j + 1, i])>0))`，其中`j`是从`0`到`i-1`。其中st是C++STL的set容器，用来保存已经出现过的单词，这样可以在`O(logn)`时间查询到子串，`(st.count(subtr[j + 1, i])>0`表示`[j+1,i]`这一子串的在st集合中数目大于0。
算法复杂度是`O(n*m*logn)`

#### 算法正确性：

正确性显然，但是要注意对于每个位置i，在枚举j的时候只要能判断`dp[i]=true`就要break，否则会超时。

