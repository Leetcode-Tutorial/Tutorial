## 题意
**中文描述**  
给定一组不重叠的区间，并向这组区间插入一个新的区间，在必要的时候要融合某些区间。  
假设这些区间已经按每个区间的开始升序排列。  
**例子 1**  
原始区间集合 `[1,3],[6,9]`, 向集合中插入 `[2,5]`。  
由于区间 `[2,5]` 和集合中的 `[1,3]` 重叠，需要融合，得到新的区间集合 `[1,5],[6,9]`。  
**例子 2**  
插入的区间也可能和原始区间集合的多个区间重叠，例如：  
原始区间集合 `[1,2],[3,5],[6,7],[8,10],[12,16]`，插入区间 `[4,9]`。  
由于区间 `[4,9]` 与 原始集合中的 `[3,5],[6,7],[8,10]` 都重叠，所以要将这四个区间融合成一个区间 `[3,10]`，从而得到新的区间集合 `[1,2],[3,10],[12,16]`。  

## 题解
### 解题思路
具体实现在 `solution1.cpp` 中。  
每个区间由两部分组成 `[start,end]`，如果两个区间 `[a1,b1]`和`[a2,b2]` 不重叠需要满足：  
`a1 != a2` 且
- 若 `a1 < a2`，则 `b1 < a2`；
- 若 `a1 > a2`，则 `b2 < a1`；  

题目描述中说明，区间集合已经按每个区间的开始升序排列，所以给定区间集合 `[a1,b1],[a2,b2],[a3,b3],...,[an,bn]`，一定满足以下条件：  
- `a1 < b1 < a2 < b2 < a3 < b3 < ... < an < bn`。

要插入的新的区间是 `[start,end]` 会将区间集合分成三个部分`left set`，`overlapped set`和`right set`：  
- `left set`：`[a1,b1],...,[ai,bi]`，`0 <= i <= n`；
- `overlapped set`：`[ai+1,bi+1],...,[aj,bj]`，`i <= j <= n`；
- `right set`：`[aj+1,bj+1],...,[an,bn]`，`i <= j <= n`；

**注意：三个集合都有可能为空！**  
并有：
- `bi < start < end < aj+1`;
- `start <= bi+1 and aj <= end`。

`overlapped set` 中的集合要和新插入的区间融合，融合之后的结果是 `[ min(ai+1, start), max(bj, end) ]`。  
**算法流程**  
所以解题的思路就是把集合中的区间按条件分成上述的三个部分：  
1.假设集合中的某个区间是 `[am,bm]`，新插入的区间是 `[start,end]`。  
- 如果 `bm < start`，`[am,bm]` 属于 `left set`；
- 如果 `end < am`，`[am,bm]` 属于 `right set`；
- 否则 `[am,bm]` 属于 `overlapped set`。  

2.`overlapped set` 中的集合和新插入的区间 `[start,end]` 融合，融合成一个区间 `[min_start, max_end]`。  
3.将三个部分组合成新的区间集合：`left set` + `[min_start, max_end]` + `right set`。  

**算法复杂度**  
区间集合中的每一个区间只被处理一次，所以时间复杂度是 `O(n)`；  
由于需要另外的空间存储三个部分的区间，所以空间复杂度也是 `O(n)`。

### 例题
原始区间集合 `[1,2],[3,5],[6,7],[8,10],[12,16]`，插入区间 `[4,9]`。  
1. 根据上述算法，将区间集合划分成三部分：  
`left set`：`[1,2]`；  
`overlapped set`：`[3,5],[6,7],[8,10]`；  
`right set`：`[12,16]`。  
2. `overlapped set` 中的集合和新插入的区间 `[4,9]` 融合，融合成一个区间 `[3,10]`。
3. 将三个部分组合成新的区间集合：  
`[1,2],[3,10],[12,16]`。

