## 题意分析

给出一个字符串，求出最长的没有重复字符的子串。

## 题解思路

+ **记录法**：首先我们必须知道怎么判断一个子串的字符是否都只出现一次。可以开一个足够大的布尔数组，然后每个字符是否出现记录在对应ascll码值的下标位置，初始化数组都为0。一旦遍历到某个字符ch，若`arr[ch]==1`则表示ch已经在之前出现过，那我们我们就可以断定这个子串不是题目要求的子串。

### 解法一：

通过枚举子串的左右下标直接枚举子串，然后对于这个子串用记录法扫一遍。一共有`n^2`个子串，“扫一遍”复杂度是O(n)，总体时间复杂度是O(n^3)，虽然难以接受，但是我们可以在此算法基础上进行改进。

### 解法二：

对于一个给定的子串起始点i，我们只关心它**最远能延伸到哪儿**。所以我们只需要枚举子串起点i，此时清空记录数组，在不断增大右边界j的同时更新记录数组，一直更新到串的右边界，或者找到某一个已经出现过的字符。那么我们就可以断定这个j是起始点i对应的右边界，更新答案即可。枚举左边界时间复杂度O(n)，延伸右边界也是O(n)，总体时间复杂度O(n^2)。

### 解法三：

我们继续改进解法二，如果对于某一个起始点i我们已经找到了他的最远右边界j，那么在解法二中我们接下来需要枚举i+1，然后又要开始重新延伸一遍寻找右边界。但是我们发现串[i...j]相比于串[i+1...j]只少了一个字符[i]，回忆我们记录数组的作用，我们完全可以擦除对于字符[i]的记录，然后对于i+1开始的串，它一直到j必然是满足的（因为即使增加一个[i]字符都能满足），所以我们可以在上一次的基础上（j）往右延伸。

更一般的：

+ 找到字符串从[0]开始的最右边界[j]，使得子串[0...j]是合法的子串；
+ 每次左边界i加一，擦除[i]的记录，右边界从i时的右边界[j]开始延伸到[j']，此时的[i+1...j']便是新的合法子串；
+ 每次更新答案。

这个算法中主要是两个指针i,j，两个指针都是从0开始最远移动到n，并且在移动的过程中是一直增加的，故时间复杂度是O(change(i)+change(j))=O(2*n)=O(n)。

## 总结：

解法三其实是一种**尺取法**，尺取法一般的做法就是定左右两个指针，每次移动左指针后更新右指针（当然两者都必须是递增的），故这个算法的英文名也叫**two pointers**。我们在解法三的末尾已经证明了尺取法的时间复杂度是O(n)，那么什么样的题能够用尺取法优化呢？答案就是当我们稍大状态的问题成立时比他的子状态也必须成立，在此题中某如果个子串[i...j]是合法的，那么对于任意的`i<=i'<=j'<=j`，都有子串[i'...j']是合法的。

