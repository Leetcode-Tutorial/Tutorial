## 题目分析

求1,2...n的第k小字典序的排列。

## 题解思路1

首先我们需要一个标记数组记录下哪些数字已经被使用了。约定[i...j]表示排列的下标i到下标j的子数组。
从第1位到第n位依次确定应该是什么数。

对于n个不同的数字的第k小字典序排列，我们可以每一位处理。首先对于第一位，如果放的是第j大的数字（假设是x），那么所有第一位的值小于x的排列都比放x的任意排列小。第一位小于x的排列总数是`(j-1)*(n-1)!`，也就是我们**需要找到这样的一个最小的j，使得j*(n-1)!>=k**，其中的含义就是不管第一位放小于x的任意数，最终的排列序都比k要小。现在找到了这样的j之后，我们便排除了`(j-1)*(n-1)`个最小排列，那么接下来问题变成了：第一位放x的排列中，找第`k-(j-1)*(n-1)`小的排列。同时记得将x标记为“已访问”
因为数字的不可重复性，相当于我们只需要解决子问题：(n-1)个数字的第`k-(j-1)*(n-1)`小的排列。
不断减小问题规模至只剩一个数即可。

## 题解思路2

C++的STL中有一个函数是std::next_purmutation()，可以直接求出某一个排列的下一个排列。于是可以直接用以下代码暴力完成。
```
class Solution {
public:
    string getPermutation(int n, int k) {
        int a[11]; 
        for (int i = 1; i <= n; i++) a[i] = i;
        for (int i = 1; i < k; i++) {
            next_permutation (a+1, a+1+n);
        }
        string ans = ""; for (int i = 1; i <= n; i++) ans += (char)(a[i]+'0');
        return ans;
    }
};
```



