## 题目分析
给定一组无重复的数字（`C`）和一个目标值（`T`），在`C`中找出所有使得数字和为`T`的组合，这么组合无重复。  
`C`中的数字可以被选择多次。  
注意：
- 所有的数字和目标值都是正整数。
- 结果集合不能包含重复的组合。

举个例子：
```cpp
数字集合： [2, 3, 6, 7]
目标值： 7
结果： 
[
  [7],
  [2, 2, 3]
]
```

## 题解
很直观的，我们可以使用回溯来解决这个问题。  
我们可以通过将数字排好序，然后在有序的数组上进行回溯来寻找所有可能的组合。  
1. 在有序数组上，我们可以实现剪枝，比如当前处理数组为`[3, 6, 7]`，而目标值是`2`，很显然没有符合条件的组合，这时我们可以直接返回上一层，即完成了剪枝；  
2. 如果当前在搜索时，已经找到了一个符合条件组合，这时我们也可以直接返回上一层，因为此时`target=0`，而数组中所有数字都是正整数，因此目标值小于当前处理数组的最小值，满足`1.`的剪枝条件 。

具体实现在 `solution.cpp`。  

**算法正确性**  
从两方面说明算法正确性：
- 是否能找到所有符合条件的组合：  
完整的回溯算法是可以找到所有的组合（搜索整个解空间），当然也就能找到所有符合条件的组合，我们的剪枝过程排除的是那些不满足条件的组合，不会减少符合条件的组合，因此本算法能找到所有符合条件的组合。  
- 已找到的组合中是否有重复的：  
回溯法找到的所有符合条件的组合中，每一个组合中数字在数组中的下标构成一个下标组合，这些下标组合都是不同的。已知，给定的数字是没有重复的，不同的下标组合一定对应着不同的数字组合，即已找到的组合中不会有重复的。

## 样例
```cpp
数字集合： [2, 3, 6, 7]
目标值： 7
```
1. 回溯算法找到的第`1`个组合是`[2,2,2]`，因为`target = 1`小于当前处理数组`[2,3,6,7]`的最小值，返回上一层（剪枝）。
2. 第`2`个组合是`[2，2，3]`，符合条件，返回上一层。
3. 第`3`个组合`[2，3]`，因为`target = 2`小于当前处理数组`[3,6,7]`的最小值，返回上一层（剪枝）。
4. 第`4`个组合`[2]`，因为`target = 5`小于当前处理数组`[6,7]`的最小值，返回上一层（剪枝）。
5. 第`5`个组合`[3，3]`，因为`target = 1`小于当前处理数组`[3,6,7]`的最小值，返回上一层（剪枝）。
6. 第`6`个组合`[3]`，因为`target = 4`小于当前处理数组`[6,7]`的最小值，返回上一层（剪枝）。
7. 第`7`个组合`[6]`，因为`target = 1`小于当前处理数组`[6,7]`的最小值，返回上一层（剪枝）。
8. 第`8`个组合`[7]`，符合条件，返回上一层.
9. 回溯结束。

返回结果：
```cpp
结果： 
[
  [7],
  [2, 2, 3]
]
```