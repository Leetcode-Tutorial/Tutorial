## 题目分析

青蛙过河，河面上一共n(2<=n<1100)个石头，初始在第1个石头上；如果上一步跳了k距离，那么下一步只能是k-1,k或者k+1，而且只能向前跳，问能否跳到最后的石头。

### 解题思路

首先容易想到一种的方法：令`f(i)` 代表是否可以到达第i个石头，那么f(n)就是问题的答案。容易看出的是，`f(1)=true`即第一个可以到达自己。考虑`f(i)`,第i个是否可达呢？然后发现推不下去了，为什么呢？因为由于步数的限制，要想知道能不能到达第i个，那么我们必须知道上一步的距离和石头。虽然这个方法失败了，但也为我们指明了方向。

所以我们**扩充**状态：令f(i,k)代表是否可以到达第i个石头，并且跳到这个石头上的步数为k，那么如果任意一个f(n,k)为true那么答案就是true。首先容易得知f(1,0)为真。其次，如果f(i,k)为真，那么f(x,k),f(x,k-1),f(x,k+1)也为真，其中x是从i跳了k(k-1或者k+1)步到达的石头的编号。

由于我们一共有O(n^2)个状态，每个状态只有3个可能的转移，如果找到坐标为x的石头编号的复杂度是k的话，那么一共的复杂度是O(k*n^2)，如果使用一个map的话，那么复杂度就是O(n^2lgn),是hashmap的话就是O(n^2)。
 
算法的正确性蕴藏在算法的描述之中，可以使用数学归纳法规范证明，有兴趣可以试试。

### 例子
 
假设坐标为[0,1,3,4,5],那么f(1,0)=true `=>` f(2,1)=true `=>` f(3,2)=true `=>` f(4,1)=true,f(5,2)=true.
