###题目分析：
给出一个数n，让我们返回构成的二叉搜索树个数。这个二叉搜索树保存着1,2...，一直到n

###解题思路：
这道题一开始思考的时候毫无头绪，但是我们将题目中例子的顺序重新排一下，这个时候我们就可以发现规律了，它可以按照根节点的值不同来进行分类。  

并且我们以`i`为根节点，左子树由`[1,i-1]`构成，右子树由`[i+1,n]`构成。由于二叉搜索树的特点，中序遍历出来的结点值是递增的。左子树`[1,i-1]`与右子树`[i+1,n]`其实是与原问题`[1,n]`是一致的，这也满足动态规划子问题的性质。下面我们通过例子来推导一下这个一维动态规划递推式。  
定义`dp[n]`为`[0,n]`能产生的Unique Binary Tree的数目  
如果数组为空，很容易我们得到，只有一种`BST`，即空树`dp[0] = 1` . 
如果数组仅有一个元素`{1}`，只有一种`BST`，单个节点  
`dp[1] = 1`  

如果数组有两个元素`{1,2}`， 那么有如下两种可能  
```cpp
1                       2
  \                    /
    2                1
dp[2] = dp[0] * dp[1]   (1为根的情况)
      + dp[1] * dp[0]  (2为根的情况。
```

再看一遍三个元素的数组，可以发现BST的取值方式如下：  
```cpp
dp[3] = dp[0] * dp[2]  (1为根的情况)
      + dp[1] * dp[1]  (2为根的情况)
      + dp[2] * dp[0]  (3为根的情况)
```
所以，由此观察，可以得出dp的递推公式为：  
`dp[n] = ∑ dp[0...k] * [ k+1....n]     0<=k<i-1` .  
由递推式我们可以得到算法时间复杂度为`0(n^2^)`

举个例子走一遍理解算法：  
就直接可以用上面所说n=3这个来当成例子  

代码在cpp文件里面
