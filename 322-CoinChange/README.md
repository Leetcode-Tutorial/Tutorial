## 题意分析
给定不同面值的硬币，以及金钱总量。写程序得到，组成给定金钱数量的最少硬币数。如果没有任何硬币的组合可以组成给定金钱数量，返回`-1`。  
注意：每种面值的硬币的数量是无限的。
```cpp
例子一：
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)
例子二：
coins = [2], amount = 3
return -1
```

## 题解
### 解题思路（1）
使用回溯法搜索所有的可能解，找到最少的硬币数。  
时间复杂度过大，不可取。  

### 解题思路二（2）
回溯法过程中有些子问题被重复地计算，而且有些子问题是没有答案的，正如例子二的情况。  
我们希望既避免重复地计算，又避免无意义的计算（没有答案的子问题）。  
生成所有可能的金钱总量就可以避免无意义的计算。  
`dp[i]`表示金钱`i`对应的最少硬币数。  
- 初始的金钱总量为`0`，硬币面值为 `coins = [1, 2, 5]`。
- 只有一个硬币可以组成的金钱分别为`[1, 2, 5]`，`dp[1]=dp[2]=dp[5]=1`
- 在金钱为`1`的基础上继续生成`[2, 3, 6]`，即`dp[3]=dp[6]=2`，而`dp[2]=min(dp[2],dp[1]+1)=1`
- 在金钱为`2`的基础上生成`[3, 4, 7]`，即`dp[4]=dp[7]=dp[2]+1=2`
- 在金钱为`3`的基础上生成`[4, 5, 8]`，即`dp[8]=2`
- 依次更新，直到计算到以金钱`amount`为基础时，结束。

当以某个金钱为基础生成接下来的金钱时，这个金钱对应的最少硬币数已经得到。  
通过这种递推的方式可以生成所有的小于`amount`的有解金钱总量，反证法证明之
- 假设某个金钱`m`是有解的，但是并没有被上述的递推过程生成
- `m`一定是由`{ m-coins[i] | 0 <= i < coins.size() }`中某个金钱生成的，这些金钱中一定有某几个（或一个）是有解的，但是也没有被递推过程生成，这样反向推理肯定可以到初始金钱数为`0`
- 既然能反推到初始金钱数，那么`m`一定是有解的。

解题的思想有点类似有向图的宽度优先搜索找最短路径
- 所有的小于`amount`的有解金钱总量对应于有向图中的结点
- `m < n `,结点`m`和`n`之前有边`m` -> `n`当且仅当 `m + coins[i] = n`
- 每条边的权值为1，对应于每次硬币数加1

