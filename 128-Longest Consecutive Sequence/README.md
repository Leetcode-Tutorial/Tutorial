## 题目分析：
给你一个未排序的数组，要在O(n)的时间复杂度内求出最长的由数组中元素组成的连续序列的长度。

### 解题思路（1）：
最直观的就是排序之后扫一遍，但这种方式时间复杂度为O(nlogn)，明显不符合要求。

### 解题思路（2）：
假设我们碰到一个数i，要求包含这个数的连续序列的长度，我们会去向左找i-1、i-2、i-3…是否在数组中，再向右找i+1、i+2、i+3…是否在序列中，直到找到第一个不在数组中的为止，然后即可知道i所在序列的长度。因此我们可以利用hash表，先将数组中所有数存到hash表中，然后对数组中的数扫一遍，每个数依次为中心向左向右检查是否在hash表中，直到扫到第一个不在hash表中的为止。当然，如果要开始扫的时候，这个数之前已经检查过了，那就无需再扫了，避免对一个连续序列重复扫描。这里hash表用unordered_map实现，时间复杂度为O(n)+O(n*hash表扫描效率)，这里hash表扫描效率可以近似看成O(1)。

#### 算法正确性：
算法的关键点在于能否保证所有连续序列都正确扫描一遍。因为每个数都会在一个连续序列中，因此每个连续序列是可以保证都检查一遍的，向左向右一个一个检查也不会将长度算错，因此上述算法是正确的。

下面举一个简单例子走一遍算法帮助理解：[100,4,200,1,3,2]。</br>
初始化：ans=0，将100、4、200、1、3、2扔到unordered_map中，是否扫描的状态记为false；</br>
扫描第一个数100:，还未扫描，向左：99不在unordered_map中，向右：101不在unordered_map中，ans=max(ans,101-99-1)=1；</br>
扫描第二个数4，还未扫描，向左：3、2、1在unordered_map中0不在unordered_map中，向右：5不在unordered_map中，ans=max(ans,5-0-1)=4；</br>
扫描第三个数200，已经扫描，跳过；</br>
扫描第四个数1，已经扫描，跳过；</br>
扫描第五个数3，已经扫描，跳过；</br>
扫描第六个数2，已经扫描，跳过；</br>
最终结果为ans=4。
