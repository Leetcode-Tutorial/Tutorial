### 题意
题目：位计数  
给定一个非负的整数num，计算所有满足0 <= i <= num的数i的二进制表示中1的个数，把所有的结果作为一个数组返回.  
举个例子：  
给定num = 5，应当返回[0,1,1,2,1,2].  
**跟进** ：  
显然，很容易想到时间复杂度为O(n*sizeof(integer))的方法，是否能使用O(n)的方法？  
空间复杂度保持O(n).  
不要使用 c++ 或者其他语言中的类似__builtin_popcount的builtin函数.  
### 题解
**算法及复杂度（69 ms）**  
由于计算一个数的二进制表示中1的个数的计算量比较小，可以先对前20个数进行二进制表示，同时计算二进制中1的个数
```
    0    0
    1    1   
   10    1
   11    2
  100    1
  101    2
  110    2
  111    3
 1000    1
 1001    2
 1010    2
 1011    3
 1100    2
 1101    3
 1110    3
 1111    4
10000    1
10001    2
10010    2
10011    3
```
通过观察以上表示，容易发现，其实2^i-2^(i + 1)中的数字的二进制中是比0 - 2^i中的数字的二进制在最高位多了一个1，也就是二进制中1的个数多了一个.  
根据以上分析，就可以先计算前2个数（0 - 2 ^ 1）的结果，然后计算出（2 ^ 1 - 2 ^ 2）的数的结果，以此类推，一直计算下去.  

**时间复杂度:** O(n)  
**代码参见本文件夹下solution.cpp**  

### 举个例子
```
// 输入数据 num = 4

// 初始化
dp[0] = 0, dp[1] = 1

// j = 2:3, i = 0:1, j ++ && i ++
dp[2] = dp[0] + 1 = 1
dp[3] = dp[1] + 1 = 2

// j = 4:4, i = 0, j ++ && i ++
dp[4] = dp[0] + 1 = 1

// 返回结果
return [0, 1, 1, 2, 1]
```
