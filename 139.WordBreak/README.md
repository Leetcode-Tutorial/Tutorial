### 题意
题目：单词断开  
给定一个非空的字符串s和一个字典wordDict，字典中包含许多非空的单词，确定字符串s是否可以分割成通过字典中的一个或多个单词组成的空格隔开的序列.假定字典中不包含重复的单词.  
举个例子，给定  
```
s = "leetcode",
dict = ["leet", "code"]. 
```
上述将返回true，因为"leetcode"可以分割成"leet code".  
**更新**:  
参数wordDict已经从原来的字符串的集合更新为字符串的数组，请重新加载代码的定义以获取最新改变.  
### 题解
**算法及复杂度（6 ms）**  
本问题是确定一个字符串是否能分割成多个单词，这些单词都在字典中出现.  
由于本题每个组成成分都是单词，也就是每次在原有字符串的返回true的基础上增加一个字典中的单词来组成新的能够返回true的字符串.发现这是一种全局同一限制性的求解问题，限制条件是每次字符串增加的都是一个存在于字典中的单词.举个例子说明一下:  
比如字符串是"leetcodeisnice"，字典是["leet", "code", "is", "nice"].要想"leetcodeisnice"返回true，需要从后向前寻找一个单词（"nice"），这个单词在字典中，并且字符串的之前的部分（"leetcodeis"）本身是返回true的.全局同一限制性的求解问题可以通过动态规划进行求解.  
由此，可以得到状态转移过程，用dp[i]表示以字符串s中以第i个字符结尾的字符串(0, i - 1)返回true或者false.那么dp[i]可以通过判断所有的j截取s得到子串s(j, i - 1)其中0 < j < j - 1存在于字典中，且dp[j - 1]已经求得为true，来确定dp[i]为true，如果不存在满足上述条件的j，则返回false.  
**时间复杂度:** O(n ^ 2 * len(wordDict)). n表示字符串s的长度，由于需要对每个位置进行求解，并且对于每个位置，需要求解之前的状态来确定现在的状态，这样的复杂度最坏为O(n ^ 2)，而每次确定过程中还需要在字典中进行搜索子串是否存在，需要再乘以len(wordDict).  
**代码参见本文件夹下solution.cpp**  

### 算法正确性
**举个例子**  
```
// 输入数据 s = "leetcode", wordDict = ["leet","code"]

// 初始化 dp[0] = true

// i = 1，"l"不存在于字典中
dp[1] = false
// i = 2，"e"不存在于字典中，"le"不存在于字典中
dp[2] = false
// i = 3, "e"不存在于字典中，"ee"不存在于字典中，"lee"不存在于字典中，
dp[3] = false
// i = 4, "t"不存在于字典中，"et"不存在于字典中，"eet"不存在于字典中，"leet"存在于字典中，且dp[i - len("leet")] = true
dp[4] = true

// i = 5，"c"不存在于字典中，"tc"不存在于字典中，"etc"不存在于字典中，"eetc"不存在于字典中，"leetc"不存在于字典中，
dp[5] = false
// i = 6，"o"不存在于字典中，"co"不存在于字典中，"tco"不存在于字典中，"etco"不存在于字典中，"eetco"不存在于字典中，"leetco"不存在于字典中，
dp[6] = false
// i = 7，"d"不存在于字典中， "od"不存在于字典中，"cod"不存在于字典中，"tcod"不存在于字典中，"etcod"不存在于字典中，"eetcod"不存在于字典中，"leetcod"不存在于字典中，
dp[7] = false
// i = 8，"e"不存在于字典中，"de"不存在于字典中, "ode"不存在于字典中，"code"存在于字典中，且dp[i - len("code")] = true
dp[8] = true

// 返回结果
return true
```    
**注意：** 为了减少一下计算量，代码中把dp[j] == true的判断放在了查找子串是否属于字典判断的前面.  
