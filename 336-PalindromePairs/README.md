## 题目分析：

给定一个字符串数组`words`，无重复字符串。问：有多少对不同的`(i, j)`满足`words[i]+words[j]`是回文串？

### 解题思路（1）
暴力枚举`(i, j)`，判断`words[i]+words[j]`是否是回文串。时间复杂度为`O(n^2*k)`。
### 解题思路（2）
将所有字符串逆序插入`map`。对于每个字符串`s`，枚举分割点`pos`，满足`[pos ~ s.size()-1]`是回文串，且`[0 ~ pos-1]`的逆串在`map`中存在。时间复杂度为`O(n*K)`。
#### 算法的正确性：
思路1无需举例。对于思路2，如`words = ["bat", "tab", "cat"]`， 则`map["tab"] = 0`, `map["bat"] = 1`, `map["tac"] = 2`, 对于`"bat"`, 我们发现`map["bat"] = 1`，且末尾串`""`为回文串。则`(0, 1)`为一解；对于`"bat"`, 我们发现`map["tab"] = 0`，且末尾串`""`为回文串。则`(1, 0)`为一解。故答案为`[[0, 1], [1, 0]]`。