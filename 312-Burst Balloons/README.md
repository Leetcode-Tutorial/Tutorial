## 题目分析

n个气球，每次你可以选择一个气球炸掉，获得的价值是`nums[left] * nums[i] * nums[right]`， 怎样选择次序使得最后获得价值最大?

### 解题思路

容易想到的是可以暴力枚举气球顺序，这样的复杂度是`O(n!)`。为什么复杂度这么大呢？

举个例子，假设我们有5个气球，那么对于爆炸顺序[1,5,2,3,4]和[5,1,2,3,4]，虽然表面看先炸1和先炸5是两个不同的顺序，但是它们的结果都是一样的，也就是说，我们把一些本质相同的状态当做不同状态处理了，导致状态数暴增。
 
为什么`[1,5...]`和`[5,1...]`是一样的呢？因为在这个时候1和5气球之间有[2,3,4]的障碍，也就是说除非[2,3,4]都炸完了，那么[1,5]之间的顺序才是有关系的；也就是说在有障碍阻隔的情况下，两端是不可能相互影响的，它们之间谁先炸都无所谓。

这样子，答案也就呼之欲出了。假设最后一个爆炸的是i，那么就把[1..n]分成了`[1..i-1]`和`[i+1..n]`这两个区间，这样子我们就把一个`[1..n]`区间爆炸的问题转化成了两个比较小的，同时也本质一样的问题。

更规范的说，令f(i,j)为i到j区间爆炸的最优值，我们去枚举最后一个炸掉的气球k，那么就可以得到`f(i,j)=max(f(i,k-1)+f(k+1,j)+nums[k]*nums[i]*nums[j])`。

算法的正确性蕴藏在转移方程中，这里不赘述了。

在实现的时候，我们可以手动在两端加上价值为1的气球，这样子f(i,j)可以重定义为从i炸到j，最后剩下两端的i,j时的最优值。这样子实现起来没有corner case。

### 例子
假设气球是[2,3,4], 加上两个1后变成[1,2,3,4,1],那么
f(0,1)=0,f(1,2)=0,f(2,3)=0,f(3,4)=0;
f(0,2)=1*2*3,f(1,3)=2*3*4,f(2,4)=3*4*1;
f(0,3)=max(f(0,1)+f(1,3)+1*2*4,f(0,2)+f(2,3)+1*3*4)
f(1,4)=max(f(1,2)+f(2,4)+2*3*1,f(1,3)+f(3,4)+2*4*1);
f(0,4)=max(f(0,1)+f(1,4)+1*2*1,f(0,2)+f(2,4)+1*3*1,f(0,3)+f(3,4)+1*4*1)
