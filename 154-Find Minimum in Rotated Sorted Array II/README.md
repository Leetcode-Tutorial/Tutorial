## 题目分析：
一个按升序排列的数组中的元素在某个位置左右互换（如[0,1,2,4,5,6,7]变成了[4,5,6,7,0,1,2]），找出数组中的最小元素，数组中的元素可能重复。

### 解题思路（1）：
最简单的方法，扫一遍数组找出最小元素，时间复杂度为O(n)。

### 解题思路（2）：
只需要扫到那个互换的中心点就可以了，即当前元素比前一个元素小的时候，它就是最小的元素，否则整个序列依旧是有序的，第一个即为最小，极端情况时间复杂度仍为O(n)。

### 解题思路（3）：
二分，初始时­­区间左指针left指向第一个元素，右指针right指向最后一个元素，令mid=(left+right)/2，每次将处于mid处的元素和right处的元素比较，如果相等right减1，如果right处的元素大则right=mid，如果right处的元素小则left=mid+1。最终结果即为left和right重合时所指向的元素，理想情况下时间复杂度为O(logn)。

#### 算法正确性：
算法的关键点在于每次二分判断后的端点指针更新。当mid处所指元素和right处的相等时，此时我们不知道mid处所指元素是在中心点的左侧还是右侧，因此可以单纯把right处的元素丢掉而不影响结果；当right处的元素大时，说明从mid+1到right这一段是不会成为答案的，它们必然在中心点的右侧；当right处的元素小时，说明left到mid这一段不会成为答案，它们必然在中心点的左侧。因此上述算法是正确的。

下面举一个简单例子走一遍算法帮助理解：[3,4,1,3,3,3,3]。</br>
初始时：left=0，right=6；</br>
第一次：mid=(left+right)/2=3，mid处元素为3，right处元素为3，right=right-1=5；</br>
第二次：mid=(left+right)/2=2，mid处元素为1，right处元素为3，right=mid=2；</br>
第三次：mid=(left+right)/2=1，mid处元素为4，right处元素为1，left=mid+1=2；</br>
left与right重合，二分结束，最终结果为1。
