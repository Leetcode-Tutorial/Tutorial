## 题目分析
找出未排序整数数组的最长递增子序列的长度。  
比如，整数数组`[10, 9, 2, 5, 3, 7, 101, 18]`，最长递增子序列是`[2, 3, 7, 101]`，因此长度为`4`。  
最长递增子序列可能不只一个，返回长度即可。  
算法的时间复杂度至少要`O(n^2)`，如果是`O(n*log(n))`就更好了。

## 题解
### 解题思路（1）
具体实现在`solution1.cpp`中。  
最长递增子序列一定是以数组中某个数字结尾的，找出以数组中每个数字结尾的最长递增子序列后，从这些递增子序列中找出长度最大的递增子序列就是整个数组中最长的递增子序列。  
整数数组`nums = [10, 9, 2, 5, 3, 7, 101, 18]`：  
- 以数组的第`1`个数字结尾的最长递增子序列是`[10]`，长度为`1`；
- 以数组的第`2`个数字结尾的最长递增子序列是`[9]`，长度为`1`；
- 以数组的第`3`个数字结尾的最长递增子序列是`[2]`，长度为`1`；
- 数组的第`4`个数字`5`，数组前`3`个数字中只有`2`小于`5`，因此以数组的第`4`个数字结尾的最长递增子序列是`[2,5]`，长度为`2`；
- 数组的第`5`个数字`3`，数组前`4`个数字中只有`2`小于`3`，因此以数组的第`5`个数字结尾的最长递增子序列是`[2,3]`，长度为`2`；
- 数组的第`6`个数字`7`，数组前`5`个数字中，`nums[2]=2, num[3]=5, nums[4]=3`都小于`7`，因此以数组的第`6`个数字结尾的最长递增子序列的长度是`1 + max(1, 2, 2) = 3`；
- 数组的第`7`个数字`101`，数组前`6`个数字中，`nums[2]=2, num[3]=5, nums[4]=3, nums[5]=7`都小于`101`，因此以数组的第`7`个数字结尾的最长递增子序列的长度是`1 + max(1, 2, 2, 3) = 4`；
- 数组的第`8`个数字`18`，数组前`7`个数字中，`nums[2]=2, num[3]=5, nums[4]=3, nums[5]=7`都小于`18`，因此以数组的第`7`个数字结尾的最长递增子序列的长度是`1 + max(1, 2, 2, 3) = 4`；
- 以数组中每个数字结尾的最长递增子序列中，最长的长度为`4`，因此整个数组的最长递增子序列的长度是`4`。

很明显上面的过程，可以通过动态规划来实现。  
**状态转移方程**  
`dp[i]`表示以第`i+1`个数字为结尾的最长递增子序列的长度。  
`dp[i] = 1 + max{ dp[j] | nums[j] < nums[i] and 0 <= j < i }`。  
**时间复杂度**  
对于数组中的每一个数字，我们都要遍历之前的结果，因此时间复杂度是`O(n^2)`。

### 解题思路（2）
具体实现在`solution2.cpp`中。  
在上述动态规划算法中，对于数组中的每一个位置，我们都要遍历这个位置前面的所有位置，从而更新以这个位置的数字为结尾的最长公共子序列的长度，先来看一下这个位置之前的递增子序列：  
整数数组`nums = [10, 9, 2, 5, 3, 7, 101, 18]`，当前位置在`nums[6] = 101`，
```cpp
len = 1	:	[10], [9], [2], [5], [3], [7]
len = 2	:	[2, 5], [2, 3], [2, 7], [5, 7], [3, 7]
len = 3	:	[2, 5, 7], [2, 3, 7]
```
长度相同的递增序列可能有多个，可是这些不都是我们需要的，比如说`[2, 3] 和 [2, 7]`，只要当前位置的数字大于`3`，就可以把`[2, 3]`这个递增子序列长度加一。  
只需要记录每一个长度的各递增子序列中末尾数字的最小值，长度为`i+1`的各递增子序列中末尾数字的最小值可以表示为`tails[i]`。  
```cpp
len = 1	:	[10], [9], [2], [5], [3], [7]			->	tails[0] = 2
len = 2	:	[2, 5], [2, 3], [2, 7], [5, 7], [3, 7]	->	tails[1] = 3
len = 3	:	[2, 5, 7], [2, 3, 7]					->	tails[2] = 7
```
`tails`数组其实是递增的，因为长度更大的递增子序列中包含了长度小的递增子序列，所以长度小的递增子序列中末尾数字的最小值一定比长度更大的递增子序列中末尾数字的最小值还小。  
当前位置的数字为`x`，当前最长的递增序列的长度为`max_len`，两种更新`tails`数组的操作：  
- 若`x`大于`tails`数组中的所有值，也就是说`x`比当前已找到的最长递增子序列的末尾数字的最小值大，这时我们找到了更长的递增子序列，`tails[max_len] = x`（`tails[max_len]`表示长度为`max_len + 1`的各递增子序列中末尾数字的最小值），`max_len = max_len + 1`。
- 若 `tails[i-1] < x <= tails[i]`，说明`x`比长度为`i`的递增子序列中末尾数字的最小值大，却不大于长度为`i+1`的递增子序列中末尾数字的最小值，`x`可以把长度为`i`的某个递增子序列的长度加一变为长度为`i+1`的递增子序列（`x`却不能扩展长度为`i+1`的任何递增子序列），这时要更新长度为`i+1`的递增子序列中末尾数字的最小值，即`tails[i]=x`。

在`tails`数组中确定`x`的位置时，可以用二分搜索实现。  
**时间复杂度**  
遍历整个数组的时间复杂度是`O(n)`，对于数组中的每个数组只需二分搜索`tails`数组，因此整体的时间复杂度是`O(n*log(n))`。
