### 题意
* 中文描述  
    给定一个整数数组nums, 找出在数组索引为i到j(i<=j)的元素的和，包括i和j位置的元素。
* 题意分析  
    求数字中一段连续序列的和。

### 题解 
* <b>方法一: 算法及复杂度（Run Time 1489ms）</b>
    * 刚开始做题的人可能还不懂什么叫做动态规划，看到这个题目，仍然可以很简单的解出来。最直接的思路就是，每次求和都直接对数组中对应的区间进行for循环迭加。
    * 每次查询的时间复杂度为O(len)，如果有n次查询，时间复杂度就是O(n*len).
    * 代码参见solution1.cpp。
* <b>方法二：算法及复杂度(Run Time 183 ms)</b>
    * 留意在Notes中提到：可以假定给出的原始数组不变；对sumRange函数有多次调用。方法一中每次查询的计算量是len，由于查询次数很多，所以可以通过对查询时的计算量进行优化。由于本问题是一个连续区间的求和问题，所以很容易想到: `sumRange(i, j) = sumRange(0, j) - sumRange(0, i - 1), i > 0`. 如果能够提前知道sumRange(0, i或j)的值，就可以在1次计算中完成一次查询。注意到上述方程中，sumRange(0, j)其实就是前j+1个数的和。所以，使用一个状态sum[j]表示前j+1个数的和，上述方程转化为`sumRange(i, j) = sum[j] - sum[i - 1], i > 0`.此方程实际就是此问题的状态转移方程。
    * 显然，计算机sum[0:len]的过程计算量是len，每次查询计算量为1, 则时间复杂度就是O(len + n)。如果n >> len， 则时间复杂度为O(n).
    * 代码参见solution2.cpp。

### 算法正确性
* 本问题方程很简单：`sumRange(i, j) = sum[j] - sum[i - 1], i > 0`，具有客观正确性。
* 举个例子验证一下：
    
    ```
    //给定数组
    Given nums = [-2, 0, 3, -5, 2, -1];
    //求前n个数的和：
    sums = [-2, -2, 1, -4, -2, -3];
    //求解：
    sumRange(0, 2) = sums[2] - 0 = 1;
    sumRange(2, 5) = sum[5] - sum[1] = -3 - (-2) = -1;
    sumRange(0, 5) = sum[5] - 0 = -3;
    ```
