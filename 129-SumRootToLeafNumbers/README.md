### 题目分析
***题干***

二叉树的每个结点包含一个从0到9的数码，每一条从根结点到叶子结点的路径表示一个数字。找出所有的路径，计算出这些数字的总和。

***题意***

举个例子
```cpp
	1
   / \
  2   3
```
路径 `1->2` 代表数字 `12`。

路径 `1->3` 代表数字 `13`。

所有路径所代表数字的总和 `sum = 12 + 13 = 25`。

### 解题思路（1）
对应的 `C++` 代码，在 `solution1.cpp` 中。

想要找出所有的根结点到叶子结点的路径，可以使用二叉树的先序遍历，我们先来看一个比题干更复杂的树。
```cpp
	8
  /   \
 9     6
  \
   4
  / \
 3   5
```
***先序遍历的过程：***
* 第一次遍历到叶子结点 `3`：`8->9->4->3`；
* 第二次遍历到叶子结点 `5`：`3->5`；
* 第三次遍历到叶子结点 `6`：`5->6`。

在先序遍历的过程中，我们需要记录当前路径上的其他结点。

在遍历第一个叶子结点 `3` 的时候，我们要记录下该路径上的其他结点 `[8 9 4]` 。只有这样，在找到叶子结点的时候，我们才可以计算出这条路径所代表的数字 `8943`。

按照先序遍历的规则，遍历叶子结点 `3` 之后，下一个要遍历的结点是第二个叶子结点 `5`。此时应该已经记录了路径上的其他结点 `[8 9 4]`，从而得到这条路径所代表的数字 `8945`。

同理，在遍历第三个叶子结点 `6`时，路径上的结点有 `[8]`，得到数字 `86`。

***如何在先序遍历时记录路径上的其他结点：***

维护一个值列表 `value_list`，从根结点 `root` 开始
* 把当前正在遍历的结点的值加入值列表的最后。
* 如果该结点是叶子结点，即我们找到了一条路径，根据列表中的值计算路径代表的数字，加入总路径和 `sums` 之中；
* 如果该结点不是叶子结点，继续以同样的方式遍历左右子树。
* 遍历完左右子树之后，从值列表中去除当前结点所对应的值。

遍历完当前结点的左右子树之后，事实上我们已经找到了以该结点为根结点的子树的所有叶子结点以及对应的路径数字。这意味着，不会再有其他未找到的路径包含该结点，所以应该把该结点对应的值从值列表 `value_list` 中去掉。

### 解题思路（2）
对应的 `C++` 代码，在 `solution2.cpp` 中。

`解题思路（1）`中，是通过记录路径上其他结点，从而求出路径所代表的数字。

我们再来看上面的二叉树。

在遍历到叶子结点 `3` 时，我们仅仅需要一个数字 `894`，就可以得到路径所代表的数字 `894 * 10 + 3 = 8943`。

***不需要额外的空间即可计算路径和***
* 即将遍历当前结点的左右子树时，同时向左右子树提供从根结点到当前结点这段路经所代表的数字。比如，要遍历结点 `9` 的左右子树时，要向其右子树 `4` 提供数字 `89`。
* 到达叶子结点，一步计算即可得到整条路径所代表的数字。
* 左右子树遍历完之后，分别返回左右子树包含的叶子结点所对应路径的总值。
* 以当前结点为根结点的子树，把当前结点左右子树返回值之和返回。

### 算法正确性
寻找路径和计算路径对应值的过程依赖于先序遍历。只要能保证
* 找到全部的路径；
* 不重复计算相同路径；
* 路径对应的值计算正确。

算法一定是正确的。

先序遍历访问每个结点一次，即每个叶子结点必定会被遍历且只被遍历一次。也就是说，每条合理的路径都能被找到并且只被计算一次。

而计算路径值的方法显然是正确的。

所以上面所说的两种方法的正确性都是可以保证的。