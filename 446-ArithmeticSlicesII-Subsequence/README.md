## 题目分析：

给定一个数组序列，可以按次序从原数组中取出部分数来组成一个等差数列。问：有多少种取法？等差数列的项数至少为3.

### 解题思路（1）
直接枚举搜索的复杂度是`O(n!)`的。
### 解题思路（2）
动态规划。我们可以用`dp[i][d]`表示以i结尾, 等差为`d`，数列长度大于`1`的数列的个数。那么我们for循环的时候，对于第i个数，枚举第j个数(`j < i`)，其中`d = a[i]-a[j]`，那么我们就会对答案产生`dp[j][d]`的贡献，同时对`dp[i][d]`产生`dp[j][d]+1`的贡献。（为什么+1？因为需要加上`a[i]`和`a[j]`两个数的情况）此外，我们还需要计算等差为0的情况。这个可以通过记录每个数出现的次数，累加到贡献里做到。时间复杂度为`O(n^2)`.
#### 算法的正确性：
举例如下：`[2, 4, 6, 8]`
初始化`ans = 0`
对于4，`ans += dp[0][2]`, (`ans = 0`), `dp[1][2] += dp[0][2]+1`, (`dp[1][2] = 1`);
对于6, `ans += dp[1][2]`, (`ans = 1`), `dp[2][2] += dp[1][2]+1`, (`dp[2][2] = 2`); `ans += dp[0][4]`, (`ans = 1`), `dp[2][4] += dp[0][4]+1`, (`dp[2][4] = 1`)
对于8, `ans += dp[2][2]`, (`ans = 3`), `dp[3][2] += dp[2][2]+1`, (`dp[3][2] = 3`); `ans += dp[1][4]`, (`ans = 3`), `dp[3][4] += dp[1][4]+1`, (`dp[3][4] = 1`); `ans += dp[0][6]`, (`ans = 3`), `dp[3][6] += dp[0][6]+1`, (`dp[3][6] = 1`)
故`ans = 3`.