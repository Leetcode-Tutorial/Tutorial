## 题目分析：
一张无向图，拥有树的特征，即有`N`个节点以及`N-1`条边，任意一个节点都可以作为树的根节点，形成一个有根的树。在所有能够构成的`N`个有根树中，给出高度最小的树的根节点。  
**树的高度：根节点到树上任一节点的路径所经过的最大边数**
### 解题思路(1): 
先从最终的那棵高度最小的树开始思考。假设每次删除所有叶节点，并形成一棵新的树，则重复这个过程下去，这棵树所剩的节点数目将为1或者2，但绝不会超过三个。  
简略证明如下：  
![Markdown](http://chuantu.biz/t5/57/1491145502x2728309712.png)  
若当前某一时刻剩下的节点情况如上图所述，则显然节点1作为根节点的树的高度将比2与3所组成的都要小。  
而上图中若无节点3，则节点1与节点2作为根节点所构成的树的高度都一样小。  
因此每次只要从图中删除叶节点，最后所剩下的1~2个点便是我们所期望的答案。然而当前的问题是，怎样的点才是**高度最小的那棵树的叶节点**?  
**在当前节点集合内，若对于节点x，有且仅有一个节点y与之相连，那么节点x便是我们所期望找到的叶节点**。  
算法过程描述如下：  
1. 将当前节点集合中，度为1的点压入一个容器内。
2. 删除容器内的节点，并更新其相连的节点的度。
3. 若节点集合内的点的数目小于等于2，则停止算法，否则继续执行步骤1.
4. 输出节点集合内剩余的点。  

对于删除操作而言，每个点至多删除一次，时间复杂度为`O(V)`，建树以及更新节点的度的操作的时间复杂度都为`O(E)`，在树上E = V - 1，因此总体而言，时间复杂度为`O(V)`。
### 解题思路(2):
*该种做法较解法1而言更为繁琐，使用了树形DP，但更为通用*  
思考我们是否能够求出所有节点的作为根节点时，树的高度？  
假设当前选取节点0作为根节点，建立一棵树。通过遍历这棵树，我们可以求得节点0的高度。与节点0直接相连的节点x作为根节点的高度实质上可以从节点0的高度转移过来。  
![Markdown](http://i1.piimg.com/1949/7cd71a2d07a027e0.png)  
对上图进行分析，节点1的最长路径为到达其子树内的结点，而对于节点4而言，最长路径为4-2-1-3，经过其父节点。因此一个节点的最长路径要么经过其父节点，要么与其子节点相连。  
考虑通过一遍dfs，计算出以节点0作为根节点的树内，每个节点x的子树的高度。即`Height[father] = max (Height[son_1], Height[son_2], ..., Height[son_n])+1`。  
而后在第二遍dfs中，将经过父节点的路径纳入考虑因素，即`Height[x] = max( Height[x], max_length_from_father)`，来自父亲的最大路径长度，可能来自**父亲的父亲**，或是**父节点除了x之外其它子树的最大高度**（实质上记录一个节点来自儿子的最大高度以及次大高度即可，若当前节点x对其贡献了最大高度，则使用次大高度）。  
建树：`O(E)`；第一遍初始化子树的高度，每个节点访问一次:`O(V)`；第二遍补充来自父亲的最大路径长度，每个节点访问一次:`O(V)`。因此总体而言，时间复杂度为`O(V)`
