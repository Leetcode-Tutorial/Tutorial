## 题目分析：
给你一个字符串s和t，在O(n)的时间复杂度内找到最短的s的子串，使得t的字符存在一个排列是这个子串的子序列，数据保证如果存在这样的子串，那么最短的子串是唯一的。

### 解题思路：
用滑动窗口的方法来解。先用一个数组cnt_in_t记下每个字符在t中出现的次数，并用一个变量existcnt_in_s表示滑动窗口中同一字符的个数不小于t中相同字符的个数的种类，同时还要用一个数组cnt_in_window记下每个字符在滑动窗口中出现的次数。在求解答案的时候，先将滑动窗口的右指针right向右滑，直到滑完整个字符串或者滑动窗口里的串是符合题目要求的子串为止，然后如果当前的窗口是符合题目要求的串，再将滑动窗口的左指针向右滑直到这个窗口不符合要求为止，此时如果当前窗口长度比之前得到的窗口要短就更新答案，然后重复上述滑动过程。由于我们不知道s和t里面包含什么字符，因此需要把数组cnt_in_t和cnt_in_window的大小开到超过字符个数。整个过程left和right都是对字符串s扫描一遍，时间复杂度满足O(n)的要求。

#### 算法正确性：
算法的关键点在于上述滑动窗口的指针滑动方式是否保证能求得最短的子串。右指针right滑动的时候，如果当前子串不满足条件，right必须继续向右滑，直到第一次出现子串满足条件位止，在左指针left固定的情况下，right如果再向右滑得到的区间必然更长；而左指针left滑动的时候，如果向右滑还能保证子串满足条件，那么left是可以向右滑的，在右指针right固定的情况下，left向右滑能保证得到更小的区间。因此上述算法是正确的。

下面举一个简单例子走一遍算法帮助理解：s=”abcae”，t=”ac”。</br>
初始时，cnt_in_t[‘a’]=1，cnt_in_t[‘c’]=1，left=0，right=0；</br>
right向右滑：</br>
s[right]=’a’，更新cnt_in_window[‘a’]=1，right变为1，还未满足要求；</br>
s[right]=’b’，更新cnt_in_window[‘b’]=1，right变为2，还未满足要求；</br>
s[right]=’c’，更新cnt_in_window[‘c’]=1，right变为3，满足要求，停止滑动；</br>
left向右滑：</br>
s[left]=’a’，更新cnt_in_window[‘a’]=0，left变为1，不满足要求，停止滑动；</br>
由于之前还未得到区间，更新答案区间左边为0，右边为2，继续滑动工作；</br>
right向右滑：</br>
s[right]=’a’，更新cnt_in_window[‘a’]=1，right变为4，满足要求，停止滑动；</br>
left向右滑：</br>
s[left]=’b’，更新cnt_in_window[‘b’]=1，left变为2，满足要求；</br>
s[left]=’c’，更新cnt_in_window[‘c’]=2，left变为3，不满足要求，停止滑动；</br>
当前区间大小比之前的最优区间小，更新答案区间左边为3，右边为4，继续滑动工作；</br>
Right向右滑：</br>
s[right]=’e’，更新cnt_in_window[‘e’]=1，right变为5，还未满足要求；</br>
由于right滑完了串s，但当起区间不满足要求，因此算法结束，最终答案为”ca”。
