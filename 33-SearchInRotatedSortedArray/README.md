## 题意
**中文描述**  
假设一个被升序排列的数组（假设没有重复的数字），实现在某个未知的枢轴上被旋转。  
例如，`0 1 2 4 5 6 7` 通过旋转之后可能变成 `4 5 6 7 0 1 2`。  
要求在数组中查找某个目标值，如果数组中有该目标值，返回该目标值的下标，否则返回 `-1`。  

## 题解
### 解题思路（1）
具体实现在 `solution1.cpp`。  
在有序的序列中查找某个目标值时，使用二分搜索效率比较高。  
被旋转之后的序列可能变成了两个有序序列的组合（之所以说是可能，是因为可能旋转了整个序列），这个时候我们可以试试可不可以继续使用二分搜索。  
**两个有序序列的性质**  
假设原序列 `a1,a2,...,an`,以某个枢纽旋转之后变成 `ai,...,an, a1,...,ai-1`，`0 <= i <= n+1`。  
- 两个有序序列是 `ai,...,an` 和 `a1,...,ai-1`。  
- `ai < an`，`a1 < ai-1`，且 `ai > ai-1`。

可以看到，左边的有序序列的最小值大于右边有序序列的最大值。  
**二分搜索策略**  
什么情况下我们可以使用二分搜索？ 可以确定当前要搜索的目标在二分中点的左侧还是右侧的时候！  
无论你要搜索的是什么目标，如果无法确定目标在二分中点的哪一侧，二分搜索还有什么意义呢。  
*接下来的描述会有一些歧义，所以先说明一下：*  
二分中点的左侧和右侧：指的是利用二分中点把一个序列切分成两个元素数量大致相等的序列；  
左侧有序序列和右侧有序序列：是针对这道题的说法，请读者切莫混淆。  
针对这道题，我们其实可以根据两个有序序列的性质来确定目标值在二分中点的左侧还是右侧：  
旋转之后的序列`nums = [ai,...,an, a1,...,ai-1]`，目标值 `target`，取二分的中点下标（索引） `mid = 1 + (n-1)/2`。
- 我们应该先判断一下这个序列是由两个有序序列组成的，还是只有一个有序序列。  
如果 `ai <= nums[mid] <= ai-1`，只有一个有序序列。否则，是由两个有序序列组成的。  
如果只有一个有序序列，使用正常的二分搜索即可；  
如果是由两个有序序列组成的，还需要接着判断。  
- 我们可以先判断中点处于左侧有序序列还是右侧有序序列，  
若 `nums[mid] > ai-1（序列最右侧）`，那么中点在左侧有序序列；  
若 `nums[mid] < ai（序列最左侧）`，那么中点在右侧有序序列；
- 确定了中点的位置，我们接着通过判断 `target` 和 `nums[mid]` 的大小关系确定目标值在二分中点的左侧还是右侧，  
**若二分中点在左侧有序序列**，即 `[ai,...,a(mid),...,an, a1,...,ai-1]`。  
若 `target > nums[mid]`，说明目标值在区间 `[a(mid+1),...,an]` 内，很明显在二分中点的左侧；  
若 `target < nums[mid]`，目标值可能在区间 `[ai,...,a(mid-1)]` 或 `[a1,...,ai-1]` 内，这时可以根据 `target >= ai` 与否判断目标值在二分中点的左侧还是右侧；  
**若二分中点在右侧有序序列**，即`[ai,...,an, a1,...,a(mid),...,ai-1]`。  
若 `target < nums[mid]`，说明目标值在区间 `[a1,...,a(mid-1)]` 内，很明显在二分中点的右侧；  
若 `target > nums[mid]`，可能在区间 `[a1,...,an]` 或 `[a(mid+1),...,ai-1]` 内，这时可以根据 `target >= ai` 与否判断目标值在二分中点的左侧还是右侧；  
- 我们已经可以判断目标值在二分中点的左侧还是右侧，可以继续进行二分搜索，接下来的判断逻辑和上述的一样。  

### 解题思路（2）
具体实现在 `solution2.cpp`。  
前一种方法判断的条件比较多，我们可以换一种角度想一想，以之前方法的策略我们是不知道两个有序序列的分界线在哪，所以我们只能通过一系列的判断条件来确定目标值在二分中点的左侧还是右侧。  
**旋转序列的另一个性质**  
旋转之后的序列是 `nums = [ai,...,an, a1,...,ai-1]`，序列中的每一个元素都偏离了原来位置的一个相同的偏移量：`i-1`。  
比如说 `an` 在当前序列中的下标是 `n-i`（下标从0开始），加上偏移量之后下标变为 `n-1`，这说明 `an` 在原有序序列中的位置是 `n-1`。  
通过这个性质，我们就可以知道在原始有序序列中的某个位置上的值是什么。比如 `ai` 在当前序列中的下标是 `0`,原有序序列中下标为 `0` 的值应该是在当前序列的下标为 `(0+[n-(i-1)]) % n = n-i+1` 的位置上，即 `a1`。  
**原始有序序列中的某个位置上的值在当前序列中的位置**  
在这个位置的下标加上偏移量 `n-i+1` 即可得到原始有序序列中的某个位置上的值在当前序列中的位置。  
当前序列中的最小值 `a1` 的下标是 `n-i+1`，上面的偏移量就是当前序列中的最小值的下标。  
如果可以找到当前序列中的最小值的位置，我们就可以找到当前序列与原始序列的对应关系。  
**新的二分搜索策略**  
假设我们找到当前序列中的最小值的位置，我们就找到了当前序列与原始序列的对应关系。我们就可以将目标值与原序列的二分中点上的值进行比较，我们的二分搜索就相当于在一个完整的有序序列上的二分搜索。
比如序列 `nums = [4 5 6 7 0 1 2]`。  
序列中的最小值的位置是 `4`，即偏移量为 `4`,若目标值是 `target=5`。  
- `left=0, right=6`，当前的二分中点是 `nums[3]=7`，原始序列中 `origin[3]=nums[(3+4)%7]=nums[0]=4`，由于 `4 < target`，目标值应该是二分中点的右侧；  
- `left=4, right=6`，当前的二分中点是 `nums[5]=1`，原始序列中 `origin[5]=nums[(5+4)%7]=nums[2]=6`，由于 `target < 6`，目标值应该是二分中点的左侧；  
- `left=4, right=4`，当前的二分中点是 `nums[4]=0`，原始序列中 `origin[4]=nums[(4+4)%7]=nums[1]=5`，由于 `target = 5`，找到目标值。

我们虽然是在旋转后的序列上进行二分，却是在原始序列上进行二分判断，相当于我们通过加偏移量的方式把旋转后的序列转换成原始的有序的序列。（请读者好好思考这句话！）  
**找到旋转后序列中的最小值**  
这是思路（2）最重要的一步，其实在旋转后的序列中找最小值比找任意值更容易一些。我们付出了比较小的代价（找最小值的判断条件比找任意值的判断条件少得多，人力成本比较低。。。）找到序列的最小值，从而把旋转后的序列转换成原始的有序的序列。  
旋转之后的序列是 `nums = [ai,...,an, a1,...,ai-1]`，取二分的中点下标（索引） `mid = 1 + (n-1)/2`，`left=0, right= n-1`。
- 若 `nums[mid] > nums[right]`，既说明序列 `[left...right]` 是由两个有序序列组成，又说明最小值在二分中点的右侧，`left=mid+1`；  
- 否则，`nums[mid] <= nums[right]`，无论序列 `[left...right]` 是一个有序序列还是由两个有序序列组成，最小值都在二分中点的左侧（包括二分中点），`right=mid`；  
- 只要 `left < right`，继续二分搜索。

