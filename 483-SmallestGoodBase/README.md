## 题目分析：

给出一个数字n，要求找到一个最小的数字k(k>=2)，使得n在k进制下各个数位上都是1。

### 解题思路：

看到题目给出的数字n的范围是[3, 1e18]，这样可以保证在二进制情况下，数位不会超过64，其他进制的数位长度一定比二进制更小。这样的进制长度我们可以枚举，对于每个进制长度的情况下，必然只有一个进制k可以满足使得所有数位上的长度都是1。
设当前枚举的数位长度是len，那么数位长度是len且各个数位上是1的数：
f[k] = k^0 + k^1 + k^2 + ... + k^(len - 1)
很显然这是一个等比序列，化成求和公式为：
f[k] = (k^len - 1) / (k - 1)
这样看来，随着k的增大，tmp也会增大，这样我们就可以对k进行二分，直到求出一个满足f[k] == n的为止，那么长度是len的情况下的结果就求出来了，由于枚举len，所以最后只要计算完所有长度下的答案，保存最小值即可。

#### 算法正确性：

因为f[k,len]是在len一定的情况下是随着k单调递增的，可以保证每个数位长度len下如果有结果，一定只有一个。因为单调性所以也可以满足二分搜索的条件，故算法正确。每次枚举之后二分，算法复杂度为O(64*logn)，可以满足题目要求。另外要注意的一点是，这里n非常大，在等比数列求和的时候不能利用求和公式，一定会溢出。而且在求和之前应该先判断判断k^(y-1) < n是否成立，因为数量巨大所以化成对数处理，判断log(n)/log(k) < y-1是否成立，如果不成立可直接推出。

