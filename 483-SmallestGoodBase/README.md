## 题目分析：

给出一个数字`n`，要求找到一个最小的数字`k``(k>=2)`，使得`n`在`k`进制下各个数位上都是1。

### 解题思路：

看到题目给出的数字n的范围是`[3, 1e18]`，这样可以保证在二进制情况下，数位不会超过64，其他进制的数位长度一定比二进制更小。这样的进制长度我们可以枚举，对于每个进制长度的情况下，必然只有一个进制k可以满足使得所有数位上的长度都是1。
设当前枚举的数位长度是len，那么数位长度是`len`且各个数位上是1的数：
`f[k] = k^0 + k^1 + k^2 + ... + k^(len - 1)`
很显然这是一个等比序列，化成求和公式为：
`f[k] = (k^len - 1) / (k - 1)`
这样看来，随着k的增大，f[k]也会增大，这样我们就可以对k进行二分，直到求出一个满足f[k] == n的为止，那么长度是len的情况下的结果就求出来了，由于枚举len，所以最后只要计算完所有长度下的答案，保存最小值即可。

#### 算法正确性：

因为`f[k,len]`是在len一定的情况下是随着`k`单调递增的，可以保证每个数位长度`len`下如果有结果，一定只有一个。因为单调性所以也可以满足二分搜索的条件，故算法正确。每次枚举之后二分，算法复杂度为`O(64 * logn)`，可以满足题目要求。
另外要注意的一点是，这里n非常大，在等比数列求和的时候不能利用求和公式，一定会溢出。如果当前枚举到数位的长度是`len`，需要求解`f[k,len]`，在进行累加运算之前要先判断公式`f[k] = k^0 + k^1 + k^2 + ... + k^(len - 1)`中最大的一项`k^(len-1) < n`是否成立，因为数量巨大所以化成对数处理，判断`log(n)/log(k) < len-1`是否成立，如果不成立就无需进行计算。
