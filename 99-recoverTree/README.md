##题目分析

给出一个交换过两个节点val的二叉索引树，将它还原，要求空间复杂度是O(n)。

##引理

任何一棵二叉索引树都能通过中序遍历的方式产生一个升序数组。比如下面的这棵二叉树：

```
    6
  /  \
 4    8
/ \   /\ 
2  5 7  9
\
 3
```
它经过中序遍历就能对应数组`[23456789]`

##题解思路

通过数-数组的转化，现在问题变成了：

+ 在一个有序数列中交换两个数，要求还原成为原数列。

我们发现问题从二维的树降到一维的数列就一下子明朗了。我们只需从左往右找到第一个下标i使得`num[i]>num[i+1]`，再从右往左找到第一个下标j使得`num[j-1]>num[j]`，那么i，j就是原数列交换的两个下标。证明就很简单了，因为原数列升序，所以当`num[i]`和右边的某一个`num[k]`交换后，下标i的数必然比它右边的数大了，下标j也是同理。当然我们在数组中不仅要记录val值，最好再记录下树上的节点指针，这样直接交换两个指针指向节点的值就行了。

时空复杂度也是显然的，遍历了树和数组，故时间复杂度是`O(n)`，空间复杂度也是`O(n)`。

读者可以试着直接在树上做判断修正，你会发现树上改不仅有很多繁琐的情况，而且有许多的边界需要注意，这也正是我们树转化为数组的目的。



