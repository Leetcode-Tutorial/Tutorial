## 题目分析

给定一组数，问有多少个区间和S(i,j)(i<=j)在[lower,upper]之间。

### 解题思路

像所有关于区间和的题目一样，第一步的套路就是算个前缀和，把S(i,j)转化成`s[j]-s[i-1]`。这样题目就转化成了，给你一组数，问有多少个(i,j)使得`i<j`且`lower<=s[j]-s[i]<=upper`。

先来考虑简单情况，那就是所有数都是非负数，那么前缀和就是不递减的。假如我们知道了对于s[j]来说，对于所有的l<=i<=r，都有`lower<=s[j]-s[i]<=upper`，那么对于s[j+1]来说，其对应的j所在的区间是`[l',r']`的话，那么一定有`l'>=l`，`r'>=r`。为什么？因为前缀和是不递减的。这样，我们就得到了一个O(n)的算法：考虑l，随着j从０到n的增长，l一直是不递减的，也就是说l最多变化n次，增长到n，同理r也是。

但现在数可能是负数，也就是说前缀和是没有不递减这样的好性质的。重新观察下前面的算法，我们希望前缀和是有序的，那怎样才能使一个无序的变成有序的呢?显而易见：排序，但排序后位置信息就已经被打乱了，就有可能没法保证j>i了。也就是说，现在我们既想排序，又想保证j>i。那么似乎就只有一种可能了：让j的范围的最小值都比i的范围的最大值都大，那么任意一个j是大于i的，这样我们就可以对j范围内的数排序，i范围内的排序。

因此，我们把序列分为前后两块，把它们分别排序，然后让j始终在后面的序列内，i始终在前面的范围内，这样就可以应用有序时候的算法了。当然，排序前，要先求出前后两块序列内的答案，怎么做？把前面的分为两块......

