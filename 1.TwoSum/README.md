### 题意
**中文描述**  
给定一个数组，返回数组中两个数的索引（下标），使得这两个数的和是一个特殊的目标值.  
可以假定每组输入都有一个确切的输出，并且一个元素不会使用两次.
### 题解
**算法及复杂度(9ms)**  
先从算法角度进行思考，本题就是要知道两个数，这两个数的和是一个给定的数。很容易的想法就是对每个数`num[i]`，求出`rest = target-num[i]`.然后在数组中查找`rest`是否存在.不存在就继续进行，存在就直接返回结果.
这样直接总的时间复杂度可能是`O(n^2)`，因为我们需要进行n的查询，每次查询时间最坏能达到n的量级.一个很小的trick就是，有一种方法可以使在一个数列中查询一个数是否存在的时间复杂度为`O(1)`，那就是使用hash的方法.这样就可以把总的时间复杂度降到`O(n)`.  
如果这个题目是在ACM中出现，通常会对数组大小有一个限制，常用的做法是把给定的数组hash到一个比较大的数组中，每次查询的时间复杂度是`O(1)`，总的时间复杂度是`O(n)`(n表示输入的数组的长度).  
但是，本题使用的是vector，并且没有长度的限制.算法就在那里，时间复杂度也是给定的.在C++11标准中，在标准STL库添加了`unordered_map`，这个是给予hash表的map，区别于STL中的`map`（基于平衡二叉树）.这个还有个小问题需要注意一下，由于数列中的一个数不能被使用两次，所以需要在`unordered_map`中先进行对当前`rest = target - num`的查找，之后再向`unordered_map`中插入当前元素.  
时间复杂度为: `O(n)`,n表示数列中所含数字的数量  
代码参见同文件夹下solution.cpp.

### 算法正确性
本问题很容易理解的算法，如果感觉理解有困难，先去学习一下hash思想.  
举个例子验证一下:

    ```
    // 给定数列
    src = [3, 2, 4], target = 6
    
    // 求一个数字的rest值
    rest = [3, x, x]
    hash[3] = hash.end(), hash[2] = hash.end(), hashp[4] = hash.end()
    查找hash[rest[0]],此时查找不到,填入第一个数字的hash值
    
    // 求第二个数字的rest值
    rest = [3, 4, x]
    hash[3] = 0, hash[2] = hash.end(), hashp[4] = hash.end()
    查找hash[rest[1]],此时仍然查找不到，填入第二个数字的hash值
    
    //求第三个数字的rest值
    rest = [3, 4, 2]
    hash[3] = 0, hash[2] = 1, hashp[4] = hash.end()
    查找hash[rest[2]],查找成功返回1, 这个数的下标是2,最后的结果是[1, 2]
    ```
