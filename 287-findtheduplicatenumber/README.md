## 题目分析：

给出一个长度为n+1的数组，其中每个数字的范围是[1,n]，其中只有一个重复的数，现在要求找出这个重复的数，并且满足以下条件：
1. 不能改动原始数组
2. 除了原始数组，只能另外开辟O(1)的空间
3. 算法复杂度一定要小于O(n^2)
4. 重复的那个数可能重复不止一次

### 解题思路：

初看这题可能有很多种方式，但是几个限制条件一加，很多算法就不可行了。

比如不能排序，因为不能改动数组；用Hash保存每个数字出现个数也不行，因为只能另外开辟O(1)的空间；直接两重循环比较则不能满足复杂度小于O(n^2)的要求；另外可能会有人用所有数的总和-(1+n) * n/2找出重复的数，但是这个方法也只能适用于重复次数只有1的情况。
考虑二分搜索，如果我们当前二分出来的答案是x，遍历数组，找出小于等于x的数一共有cnt个。
很显然，如果cnt > m，那么说明在[1,x]中一定存在重复的数，这时就应继续二分搜索[1,x]。
如果cnt <= m，那么说明在[x,n]中有重复的数，这时候继续二分[x,n]，直到找到最终重复的数即可。
举例：{1，3，5，4，7，5，5，6}  
初始化下界 l = 1，上界 r = 7  
第一步：m = (1 + 7) / 2 = 4，求出小于等于m的数集合为{1,3,4}，cnt = 3 < m， 故 l = m + 1 = 5；  
第二步：m = (5 + 7) / 2 = 6，求出小于等于m的数集合为{1,3,4,5,5,5,6}，cnt = 7 > m， 故 r = m = 6；   
第三步：m = (5 + 6) / 2 = 5，求出小于等于m的数集合为{1,3,4,5,5,5}，cnt = 6 > m， 故 r = m = 5；  
至此，l == r，算法终止，返回l。   
发现5果然是重复元素。  


#### 算法正确性：

因为数的范围是[1,n]，而一共却有n+1个数，根据抽屉原理，一定存在至少一个重复的数。
且题目讲明了只有一个重复的数存在，算法是基于这样的性质设f(x)是数组中小于等于x的数的数目，那么g(x)=x-f(x)只有小于0，大于0，等于0三种取值。如果最终答案是ans，当x < ans时，g(x) > 0，当x >= ans时，g(x) <= 0，这样看来也满足x增大，g(x)不增的性质，故可以通过二分x来搜索答案。
没有改动原始数组，满足条件1；只开辟了几个变量的空间，满足条件2；算法复杂度为O(nlogn)，满足条件3；能找到重复多次的数，满足条件4。
综上所述，该算法正确。
