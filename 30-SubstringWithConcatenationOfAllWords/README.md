## 题目分析

给定一个字符串s，和一组等长的单词words。求出s中所有满足条件的位置，使得将words中单词排列后与s中对应位置开始的字符串匹配。

比如s=`"barfoothefoobarman"`，words=`["foo", "bar"]`，那么0和9都是满足条件的起始位置。

约定：下面我们用s[i,l]代表s中从i开始，长度为l的子串；n代表words中单词个数，wn代表每个单词的长度；m代表字符串s长度。

### 解题思路(1)
最容易想法的就是暴力枚举起点，然后判断是否匹配。比方说上面例子中，现在枚举起点0，子串s[0,3]=`“bar"`在words中出现了，而且子串s[3,3]=`"foo"`也在子串出现了，这时words中每个单词都被覆盖到了，那么0就是一个满足条件的位置。

由于每个位置都要枚举一遍，如果判断s[i,wn]所对应words中的单词的复杂度是O(k)，那么每次判断的复杂度是O(n*k)，因此总的复杂度是O(m*n*k)。

### 解题思路(2)

观察题面，我们还有一个条件没有用到，那就是所有单词都是等长的。
考虑一下，如果我们知道了从s[i,wn*n]覆盖words中单词的信息，那么s[i+wn,wn*n]覆盖words的信息有很大一部分是与s[i,wn*n]重合的。
```
[i,wn][i+wn,wn][i+2*wn,wn]...[i+(n-1)*wn,wn]
	  [i+wn,wn][i+2*wn,wn]...[i+(n-1)*wn,wn][i+n*wn,wn]
``` 
也就是说，我们从s[i,wn*n]转移到s[i+wn,wn*n]的时候，只需要把s[i,wn]删掉，把s[i+n*wn,wn]加上，而不用像方法(1)一样重新扫一遍。

因此我们把起点分成wn组，每组中所有的起点相差都为wn。
```
[0,wn,2*wn,3*wn,4*wn...]
  [1,wn+1,2*wn+1,3*wn+1,4*wn+1...]
    [2,wn+2,2*wn+2,3*wn+2,4*wn+2...]
      ......
        [wn-1,2*wn-1,3*wn-1,4*wn-1...]
```
容易看出每个起点都出现了一次，每组中向下一个转移只需要O(k)的复杂度，因此总的复杂度是O(m*k)。

需要注意的是words中单词可能重复，实现的时候我们用一个map去记录每个单词还需要出现多少次，添加单词的时候就将对应的值减一，当值小于等于0时说明这个单词已经全部出现了，删除单词的时候就将其对应的值加一，当为正数的时候就说明这个单词没有全部被覆盖。

#### 例子
s=`"barfoobarfoobarman"`，words=`["bar","foo", "bar"]`。
以起点i=0的组举例：
首先初始化单词还需要出现的次数，`"bar"`->2,`"foo"`->1。
i=0，插入s[0,3]=`"bar"`，此时`”bar"`->1，`"foo"`->1。
i=3，插入s[3,3]=`"foo"`，此时`"bar"`->1，`"foo"`->0，`"foo"`已经覆盖完。
i=6，插入s[6,3]=`"bar"`，此时`"bar"`->0，`"foo"`->0，`"bar"`也已经覆盖完，因此0是一个合法的起始位置。
i=9，这时需要先删除s[0,3]=`"bar"`，加入s[9,3]=`"foo"`，此时`"bar"`->1，`"foo"`->-1。
i=12，这时需要先删除s[3,3]=`"foo"`，加入s[12,3]=`"bar"`，此时`"bar"`->0，`"foo"`->0。因此6也是合格合法的起始位置。
i=15，这时需要先删除s[6,3]=`"bar"`，s[15,3]=`"bar"`未出现，此时`"bar"`->1，`"foo"`->0。