## 题目分析：

给出一串n个数的序列，要求将这n个数分成m个块，算出每个块中数的总和，要保证总和的最大值最小。

### 解题思路：

最小化最大值，显然是二分搜索结果判断是否可行，关键在于判断函数的设计。
判断函数可以从另一个角度考虑，假设当前枚举的最大值是limit，那么肯定每个块的最大值都不能超过这个限制。
那么从左到右扫一遍，记录当前的累加和now，如果扫到第i个数nums[i]的时候，now > sum，说明nums[i]需要放到新的块中，块的数目c加一。这样最后在保证所有块的总合都小于等于最大值的情况下，看c是否小于等于m，若c <= m，说明还可以继续二分更小的结果，否则就要二分更大的结果。

#### 算法正确性：

举例说明：
数组序列为[1,3,2,1,5]，要求分成3块，初始化二分范围是[5,12]，f(x)为总和最大值不超过x的情况下最少分成几块。
step 1：l = 5, r = 12, mid = 8, 则f(8) = 2 <= 3.
step 2: l = 5, r = 8, mid = 6, 则f(6) = 2 <= 3.
step 3: l = 5, r = 6, mid = 5, 则f(5) = 4 > 3.
step 4：l = 6, r = 6, l == r, 所以最终结果就是6.
每次二分都需要一遍遍历，这样算法的复杂度就是O(n * logx)，其中x是数的大小，n是数组长度。

