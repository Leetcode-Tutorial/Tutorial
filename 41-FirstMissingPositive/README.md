## 题目分析：

给一个int型数组，问：不在该数组中的最小正整数。时间复杂度要求 `O(n)` ，空间复杂度要求为常数。

### 解题思路
常规思路就是排序，扫一遍。时间复杂度为 `O(nlogn)` 。题干要求的时间复杂度让我们想到需要类似于计数排序，但计数排序的空间复杂度并不满足题干要求。挖掘题面信息，我们发现题目要求的是正整数，int型最高位为0。因此我们可以利用好这个最高位来打标记。
我们首先可以预处理出所有正整数，然后用类似计数排序去标记该数组中的正整数，答案最大为数组中的正整数的个数 + 1，若遇到更大的正整数，直接忽略掉不做标记即可。
时间复杂度为 `O(n)` ，额外空间复杂度为 `O(1)` 。
如2, 5, -1, 1, 预处理后为2, 5, 1, 各正数为02, 05, 01, (0表示符号位), 扫到2时, 数组变为02, 15, 01; 扫到5时，越界，忽略, 数组仍为02, 15, 01; 扫到1时, 数组为12, 15, 01。最后计算答案时，从前往后扫描，发现第3个数符号位为0, 故答案为3。
