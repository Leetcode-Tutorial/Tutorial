## 题目分析

给出一个升序链表，构造出一个平衡二叉树。

## 题解思路（1）

根据108的方法，我们显然可以通过`O(n)`的时间复杂度将链表里面的元素抓下来存到数组中，那么直接按照108的做法构建即可。这样做的时间复杂度达到了`O(n)`，但是有额外`O(n)`的空间开销，也就是我们用来存链表元素的数组。

## 题解思路（2）

考虑避免额外空间消耗的做法。对于链表`[1->2->3...->n]`，按照我们的做法要构造`[1->2->...->mid-1][mid][mid+1->mid+2...->n]`，只需要在递归的时候传递当前链表指针的引用即可。每当构造完左子树，指针便已经指向了当前子树的根，具体的：

```
function (l, r, pointer) {
	计算mid=ceil((l+r)/2)
	递归构造(l,mid-1,pointer)
	给当前子树根节点赋值
	pointer=pointer->next
	递归构造(mid+1,r,pointer)
	返回当前子树
}
```

这样空间额外开销就没有了。容易发现时间复杂度也是`O(n)`。



