### 题意
题目：下一个排列  
实现下一个排列，将数字重新排列成数字的下一个更大排列.  
如果这种排列不存在，那么就排列成最小的排列序（即上升的序列）.  
替换必须在原位置，不要分配额外的内存.  
举个例子，左边是输入，右边是输出：  
```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```  
### 题解
**算法及复杂度（13 ms）**  
本题可以直接使用C++ STL中的next_permutation函数直接实现下一个排列.  
如果要自己实现下一个排列，有一种经典的算法：
```
1. 求满足关系式pj-1 < pj的j的最大值，设为i，即 i = max{j|pj-1 < pj}，如果不存在i，则直接对序列排序即可
2. 求满足关系式pi-1 < pk的k的最大值设j，即 j = max{k|pi-1 < [k}
3. pi-1与pj互换位置，得到pp = p1p2...pn
4. 在pp中，把pipi+1...pn部分逆序，所得ppp序列即为所求
```
其主要思想是判断数列最后两个数是否升序，如果升序则下一次排列直接为这两个数的降序，否则就要根据换位构造一种最后两个数的升序排列.
**时间复杂度:** O(n)
**代码参见本文件夹下solution.cpp**  

### 举个例子 
```
// 输入数据 p = 3421

// i = max{j|pj-1 < pj} = 1

// j = max{k|pi-1 < pk} = 1

// 交换pi-1和pj，得到
4321

//将pipi+1...pn部分逆序，得到
4123
```
