## 题意分析

给出一个n*m的网格图，一个人从左上角走到右下角，每次只能往右或者往下走。每到一个格子他的HP就会增加对应的值。求出一个最小的初始值使得存在一条路径，路径上的任意时刻HP值都为正。

## 题解思路
### 解法一：正向做法

显然我们可以得到一种算法：随便枚举初始HP，判断是否可行。但是假设HP的可行域落在[l,r]，我们最差需要花费`O((r-l)*judge)`的时间，这样的复杂度显然无法接受。
考虑到问题的特殊性，因为初始HP有二分性质，所以我们可以二分初始时刻的HP，假设此时的答案下界和上界是l,r，那么我们只需要判断`mid=(l+r)/2`，如果mid满足，那么上界必然也满足，我们便可以把上界下降到mid，否则我们可以把下界上升到mid。那么这样的做法在于判断一个初始血量x能否满足条件。

显然我们对于当前在于某个格子的状态，我们只关心当前我走到了这个位置，并且之前没有负数或零HP的拥有的最大HP。于是便可以顺理成章的设计出`dp[i][j]`这个状态，表示我走到`(i,j)`这个格子，之前路径不存在负数或零的最大拥有HP。如果此时HP为正，那么转移便只需要将他往右或者往下走，更新新格子的dp值即可。

判断时的时间复杂度是`O(nm)`，二分答案的时间复杂度是`O(lg(max))`，其中max表示可行域的区间长度，总时间复杂度是`O(n*m*lg(maxn))`。

### 解法二：逆向思维

现在我们换一种状态设计，对于每个格子，我想知道它到达终点最少需要多少HP才能使得路径存在。因为这个是“格子到终点“的路径关系，所以我们可以从终点出发往前推。如果在某个格子`(i,j)`最少需要`dp[i][j]`的HP才能使得存在到达终点的路径，我们就拿它转移到`(i-1,j)`为例，在`(i-1,j)`这个格子就最少需要`dp[i][j]-dungeon[i-1][j]`的HP。当然在任意时刻需要的HP至少都为1，所以我们必须保证不能出现负数或者零。

少了二分答案的过程，逆向的时空复杂度为`O(nm)`。

## 总结

二分答案+check二分结果这是一种非常有用的方法，在许多时候能够非常逻辑通顺地解决问题；逆向思维这样的思想也应该掌握，比如在本题中，不仅大大优化了时间复杂度，而且还减少了编程量。

本题的解法一在solution1.cpp中，解法二在solution2.cpp中。

