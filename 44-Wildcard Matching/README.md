## 题目分析：
给你s和p两个字符串，它们均由小写字母以及'?'、'\*'组成，其中'?'与任何一个字符匹配，'\*'与任何长度字符串匹配（可以为空），问s和p是否完全匹配。

### 解题思路：
可以用动态规划来解决，用dp[i][j]表示s串的前i个字母和p串的前j个字母是否匹配。首先处理字符'\*'，如果s[i-1]='\*'，就检查dp[i-1][0]到dp[i-1][lenp]的状态，遇到第一个为true的dp[i-1][k]后，j大于等于k，dp[i][j]均为true，j小于k，dp[i][j]均为false。如果p[j-1]='\*'，就检查dp[0][j-1]到dp[i][j-1]的状态，如果这里面有一个状态为true，那么dp[i][j]就为true。如果s[i-1]和p[i-1]均不为'\*'，那就进行单个字符的匹配，当s[i-1]=='?'或p[j-1]=='?'或s[i-1]==p[j-1]的时候dp[i][j]=dp[i-1][j-1]，否则dp[i][j]=false。此外，边界还需要初始化，dp[0][0]=true，对于s，如果s[i-1]='\*'那么dp[i][0]=dp[i-1][0]，否则dp[i][0]=false，对于p，如果p[i-1]='\*'那么dp[0][i]=dp[0][i-1]，否则dp[0][i]=false。最后结果为dp[lens][lenp]。如果按照上述做法极端情况下时间复杂度为O(lens^2\*lenp)，但我们可以设一个hastrue数组，hastrue[i]表示dp数组的第i列中是否有true，这样时间复杂度可以降至O(lens\*lenp)。

#### 算法正确性：
算法的关键点在于状态转移方程那里，如果s[i-1]和p[j-1]匹配上，那么s[0…i-1]与p[0…j-1]是否匹配的问题就变成s[0…i-2]与p[0…j-2]是否匹配，dp[i][j]的状态就与dp[i-1][j-1]相同；如果s[i-1]和p[j-1]没匹配上，那么s[0…i-1]与p[0…j-1]肯定就没匹配上；而字符’*’可以与任意一个串匹配，此时一个状态就可以由上一层前面的所有状态转移而来。因此该状态转移方程是正确的。

下面举一个例子走一遍算法帮助理解：s="?a\*"，p="b\*a"。
初始化边界：
dp[0][0]=true；
s[0]!='\*'，dp[1][0]=false；
s[1]!='\*'，dp[2][0]=false；
s[2]=='\*'，dp[3][0]=dp[2][0]=false；
p[0]!='\*'，dp[0][1]=false；
p[1]=='\*'，dp[0][2]=dp[0][1]=false；
p[2]!='\*'，dp[0][3]=false；
hastrue[0]置为true，其余为false。
然后开始进行状态转移：
i=1，由于s[0]!='\*',进入内层循环：
j=1，由于s[0]=='?'，dp[1][1]=dp[0][0]=true，hastrue[1]置为true；
j=2，由于p[1]=='\*'，dp[1][2]=hastrue[1]=true，hastrue[2]置为true；
j=3，由于s[0]=='?'，dp[1][3]=dp[0][2]=false；
i=2，由于s[1]!='\*',进入内层循环：
j=1，由于s[1]!=p[0]，dp[2][1]=false；
j=2，由于p[1]=='\*'，dp[2][2]=hastrue[1]=true，hastrue[2]置为true；
j=3，由于s[0]=='?'，dp[2][3]=dp[1][2]=true，hastrue[3]置为true；
i=3，由于s[2]=='\*'，检查上一行，第一个true出现在dp[2][2]，因此dp[3][2]=dp[3][3]=true，hastrue[2]=hastrue[3]=true；
最终答案为dp[3][3]=true。
