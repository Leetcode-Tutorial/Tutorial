## 题目分析：

给出一串n个数的序列nums，要求对于每个数nums[i]求出除了这个数以外的其他所有数的乘积。 
如：[1, 2, 3, 4]， 所求结果就是[24, 12, 8, 6] 
另外有条件： 
1. 算法不允许使用除法。 
2. 时间复杂度要求O(n)。 
3. 除了输出的结果数组以外，只能另外开辟O(1)的空间。 

### 解题思路：

既然不能使用除法，对于每个数，其实我们就是想要知道它左边的数的乘积以及右边数的乘积。
可以考虑两次遍历： 
第一次从左往右，维护一个前缀乘积l，保存[1,i-1]的乘积，每次给第i个数的结果res[i]乘上l，然后再更新l为[1,i]的乘积，这样扫一遍就保证n个数都乘上了自己左边的数的乘积。 
第二次从右往左，维护一个后缀乘积r，保存[i+1,n]的乘积，每次给第i个数的结果res[i]乘上r，然后再更新r为[i,n]的乘积，这样扫一遍就保证n个数都乘上了自己右边的数的乘积。 
这样便利两次即可保证res数组内就是最后所求的结果。

#### 算法正确性：

算法需要遍历两次，符合时间复杂度O(n)的要求；空间上只开辟了l和r两个O(1)的变量空间，而且没有使用除法，符合题意，所以该算法正确。
