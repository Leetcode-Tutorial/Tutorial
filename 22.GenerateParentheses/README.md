### 题意
**中文描述**  
给定n对圆括号，写一个函数生成所有的正确匹配的圆括号组合.  
几个例子，给定 n = 3, 一个结果集如下:  
```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```  

### 题解
**算法及复杂度（3 ms）**  
题目要求使用回溯法进行求解.不了解回溯法的可以参考第17题对回溯法思想的介绍.  
简单观察一下本题的特征，发现:（1）每一个答案字符串的第一个圆括号都必须是左括号"("，所以第一个位置是不需要回溯的.（2）另外，可以发现，其实对于给定的n，在每个答案字符串中左括号和右括号的数量都是n.并且在任意一个位置都有左括号的数量大于右括号的数量.（3）根据前两条特性进行设计，很容易发现只要对每个位置满足第（2）条条件下，依次进行左右括号的遍历就可以了.  
本题采用深度优先搜索的思想进行，每层对左右括号进行搜索，前提是满足上述的（1）（2）条件.  
***时间复杂度:*** 最差情况是1/4C_{2n}_{n}，其中n表示n对圆括号，相当于在2n个位置中找到n个位置，前去不满足条件（1）的情况，为总数量的一半，并减去不满足第（2）个条件的情况，这个数量大约多于上一步求得的数量的一半.
***代码参见本文件夹下solution.cpp***  

### 算法正确性
**正确性证明**
搜索过程等价于枚举.  
**举个例子**  
```
// 输入 n = 3
// 初始化, 中间结果为temp, 最终结果为result, 左括号数量为left, 右括号数量为right
temp = "(", result = [], left = 1, right = 0

// 进入第一层，左括号数量不等于n，temp中追加左括号，进入下一层
temp = "((", result = [], left = 2, right = 0

// 左括号数量不等于n，temp中追加左括号，进入下一层
temp = "(((", result = [], left = 3, right = 0

// 左括号数量等于n，并且左括号数量大于右括号，temp中追加右括号，进入下一层
temp = "((()", result = [], left = 3, right = 1

// 左括号数量等于n，并且左括号数量大于右括号，temp中追加右括号，进入下一层
temp = "((())", result = [], left = 3, right = 2

// 左括号数量等于n，并且左括号数量大于右括号，temp中追加右括号，进入下一层
temp = "((()))", result = [], left = 3, right = 3

// 左括号等于n且右括号等于n， result 中追加temp， 返回上一层
temp = "((()))", result = ["((()))"], left = 3, right = 2

// 继续返回，直到遇到返回到左括号的位置，换成右括号，继续进行搜索
// 之后过程类似，直到搜索完所有的顺序，最后返回result
```  
