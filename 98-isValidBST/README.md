## 题目分析

判断一棵树是否是合法二叉搜索树。

## 二叉树节点编号

我们可以按照先序遍历的顺序给每个节点编号。设置一个全局变量x，初始化为0，每次进入一个新的节点时x+1，这时候x便是当前节点的编号，按照搜索顺序接下来搜索当前节点的左孩子（如果存在），那么便可以知道当前节点左孩子的编号是自己的编号+1。当遍历完左子树回到自身时，因为全局变量每次新遍历一个节点都会+1，所以右孩子的编号便是x+1。

伪代码可以写作：

```
dfs (node *u) {
	x++;
	u的编号cur = x;
	u的左孩子编号 cur_left = cur+1;
	dfs (u->left) {}
	u的右孩子编号 cur_right = x+1;
	dfs (u->right) {}
}
```

## 题解思路

问题等价为，判断是否对于二叉树上每个节点都有：

+ 他的左子树上所有节点的值小于自身；
+ 他的右子树上所有节点的值大于自身。

判断第一点，只需要找到左子树上的最大值，判断是否小于自身；同样的，只需要找到右子树上的最小值，判断是否大于自身。
至此问题的关键已经抽象出来：找到树上所有节点为根的子树的最大/小值。
采取递归的策略可以得到`Min[u]=min(Min[u->left],Min[u->right],u->val)`，注意这里的下标要用节点的编号，最大值也同理。

上述思想是树上动态规划的思想，处理一类树上的问题，这类问题的一般共性是父节点的答案需要通过孩子节点确定。


