## 题目分析

给你一串数，用一个大小为k的滑动窗口从左向右走，问每一次滑动时窗口内的最大值是多少。

### 解题思路

最简单的方法就是每k个暴力找一次，这样复杂度显然是O(nk)的。

然而，想象一下，每次我们向右移动的时候，其实是有很大一部分的重合的，以前的信息我们依然可以利用。
```
i,i+1,i+2...i+k-1
  i+1,i+2...i+k-1,i+k
```
考虑一下，假设窗口左端点为i时的最大值有两种情况:
* 在i的位置，当我们右移的时候，我们直接i删掉了，加入了i+k，那么这时的最大值是[i+1,i+k-1]的最大值和i+k的值中较大的那个
* 如果在[i+1,i+k-1]区间内，那么我们只要把之前的最大值和i+k比较一下。也就是说，这时候i位置上的值已经不重要了，因为反正它也不会成为最大值。

我们仔细考虑一下后一种情况，为什么可以直接删掉i，直接用之前的答案？如果i,j都在窗口里，而且i<j，nums[j]>nums[i]的话，那么i位置的数永远也不可能成为最大值了。想一想，为什么？

这样，每个窗口里有可能在以后成为最大值的点，一定是单调减的。因此，我们去维护一个当前窗口的一个单调递减的队列，这样每个数只会入队一次，出队一次，时间复杂度就被减小到了O(n)。

### 例子

nums = [1,3,-1,-3,5,3,6,7], and k = 3

首先前k个的单调减为[3,-1]
接着我们插入-3，这个时候可以直接放进去，变为[3,-1,-3]
插入5,这个时候要把3,-1,-3都删掉，队列变为[5]。
接着插入3，队列变成[5,3]
插入6，队列变为[6]
插入7，队列变为[7]
