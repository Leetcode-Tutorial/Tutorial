## 题目分析：

给出两个字符串s和t，问在s中可以找到几个与t相同的子序列

### 解题思路：

思路是dp，`dp[i][j]`表示在字符串`s[0..j-1]`中有多少个子序列等于字符串`t[0..i-1]`，那么对于`dp[i][j]`就有两种情况转移：
1. 如果`t[i - 1] != s[j - 1]`，则`dp[i][j] = dp[i][j - 1]`；因为`s[j - 1]`已经不能参与构成`t[0..i-1]`了。
2. 如果`t[i - 1] == s[j - 1]`，则`dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]`；因为如果`s[j - 1]`和`t[i - 1]`相同，那么找到的符合条件的子序列就有两种，一种是以`s[j - 1]`作为末尾的，这样的情况数是`dp[i - 1][j - 1]`，另一种是不以`s[j - 1]`作为末尾的，这样的情况数是`dp[i][j - 1]`。
这样状态转移方程就出来了，剩下的是初始化，因为`s[0..j-1]`中一定能找到一个空序列，所以初始化为`dp[0][j] = 1`，其中j范围从0到n。

#### 算法正确性：

举例说明：如`s = "abacbc"`，`t = "abc"`，按照上述思路，因为`s[6] == t[3]`，那么考虑`dp[3][6]`就要从两种情况转移：
1. 构成t的字符串用到了s[6]，那就要计算在s[1..5]的范围内能组成t[1..2]的方案数，也就是从dp[2][5]转移过来。
2. 构成t的字符串没有用到s[6]，那就要计算在s[1..5]的范围内能组成t[1..3]的方案数，也就是从dp[3][5]转移过来。
状态转移考虑的两种情况没有重复和遗漏，且初始化也符合常理，所以算法正确，时间复杂度为`O(n*m)`。

