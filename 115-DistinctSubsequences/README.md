## 题目分析：

给出两个字符串s和t，问在s中可以找到几个与t相同的子序列

### 解题思路：

思路是dp，`dp[i][j]`表示在字符串`s[0..j-1]`中有多少个子序列等于字符串`t[0..i-1]`，那么对于`dp[i][j]`就有两种情况转移：
1. 如果`t[i - 1] != s[j - 1]`，则`dp[i][j] = dp[i][j - 1]`；因为`s[j - 1]`已经不能参与构成`t[0..i-1]`了。
2. 如果`t[i - 1] == s[j - 1]``，则`dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]`；因为如果`s[j - 1]`和`t[i - 1]`相同，那么找到的符合条件的子序列就有两种，一种是以`s[j - 1]`作为末尾的，这样的情况数是`dp[i - 1][j - 1]`，另一种是不以`s[j - 1]`作为末尾的，这样的情况数是`dp[i][j - 1]`。
这样状态转移方程就出来了，剩下的是初始化，因为`s[0..j-1]`中一定能找到一个空序列，所以初始化为`dp[0][j] = 1`，其中j范围从0到n。

#### 算法正确性：

状态转移考虑的两种情况没有重复和遗漏，且初始化也符合常理，所以算法正确，时间复杂度为`O(n*m)`。

