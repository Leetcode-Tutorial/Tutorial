## 题目分析：
给你n个非负整数表示n个连续区域各自的海拔，每个区域宽度为1，问一场足够大的雨后有多少单位的水能储存在里面。也可以理解成在一个有若干黑块和白块的矩形中，有多少个白块的左边和右边（不一定相邻）都至少有一个黑块。

### 解题思路（1）：
可以开个二维矩阵存每个位置是黑块还是白块，然后一行一行扫描，记下最左和左右的黑块位置l、r和总黑块数cnt，这一行的答案就为r-l-cnt+2，最终答案就是每一行的答案和。这种方法时空复杂度都为O(n\*max(height))，当数据很大的时候这种方法是不能接受的。

### 解题思路（2）：
开两个栈，一个栈s存海拔，另一个栈id存该海拔对应的位置。对n个海拔从左往右扫描，对第i个海拔为height[i]的区域，初始化之前海拔变量pre为0，检查栈顶，当栈不空且s栈的栈顶海拔s.top()<=height[i]的时候，重复下列操作：答案增加(i-id.top()-1)\*(s.top()-pre)，然后pre更新为s.top()，弹出两个栈的栈顶。需要注意的是退出来后如果栈不空则还要增加答案(i-id.top()-1)\*(height[i]-pre)，然后再把height[i]和i分别压入s和id栈。这个思路时空复杂度均为O(n)，完全可以接受。

#### 算法正确性：
算法的关键点在于栈的存储和答案计算的部分。关于栈的存储，由于扫描是从左往右进行的，因此如果出现一个高海拔区域会把左边所有低海拔区域都挡住，后面的计算就不需要用到这些低海拔的区域了，所以从栈底到栈顶海拔逐渐减小。关于答案计算，可以理解为从低到高依次计算一个小矩形的面积，长为当前区域和栈顶区域的距离，宽为栈顶或当前区域与上次计算区域的高度差。

下面举一个简单例子走一遍算法帮助理解：[2,1,0,4,2,3]。初始时s栈和id栈均为空，答案ans为0。</br>
第一步：height[0]=2，pre置为0，检查栈顶，栈s为空，直接将2压入s栈，0压入id栈；</br>
第二步：height[1]=1，pre置为0，检查栈顶，s.top()=2>1，直接将1压入s栈，1压入id栈；</br>
第三步：height[2]=0，pre置为0，检查栈顶，s.top()=1>0，直接将0压入s栈，2压入id栈；</br>
第四步：height[3]=4，pre置为0，检查栈顶，s.top()=0<4，ans增加(i-id.top()-1)*(s.top()-pre)=0，pre=s.top()=0，弹出s和id栈的栈顶，继续；</br>
检查栈顶，s.top()=1<4，ans增加(i-id.top()-1)*(s.top()-pre)=1，pre=s.top()=1，弹出s和id栈的栈顶，继续；</br>
检查栈顶，s.top()=2<4，ans增加(i-id.top()-1)*(s.top()-pre)=2，pre=s.top()=2，弹出s和id栈的栈顶，继续；</br>
检查栈顶，栈s为空，直接将4压入s栈，3压入id栈；</br>
第五步：height[4]=2，pre置为0，检查栈顶，s.top()=4>2，直接将2压入s栈，4压入id栈；</br>
第六步：height[5]=3，pre置为0，检查栈顶，s.top()=2<3，ans增加(i-id.top()-1)*(s.top()-pre)=0，pre=s.top()=0，弹出s和id栈的栈顶，继续；</br>
检查栈顶，s.top()=4<3，跳出，ans增加(i-id.top()-1)*(s.top()-pre)=1，pre=s.top()=2，将3压入s栈，5压入id栈。</br>
最终ans为4。
