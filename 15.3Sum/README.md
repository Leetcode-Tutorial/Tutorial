### 题意
**中文描述**  
给定一个包含n个整数的数列S, 找出所有的独特的3个数列中的元素a,b,c使得a + b + c = 0。   
注意: 结果集只包含不重复的三元组。  

### 题解
**算法及复杂度(382 ms)**  
本题与第1题（[Two Sum](https://leetcode.com/problems/two-sum/#/description)）有类似之处，从题目上就可以看出来，第1题是两个数的和，而本题是求三个数的和。  
由于要求三元组不能重复，所以可以想到进行排序，这样就可以很容易的发现重复的三元组。为什么通过排序容易发现重复结果？如果在无序的数列中进行操作，得到了满足`a + b +c = 0`之后，还需要对三元组的重复情况进行比较，此时比较好的一种做法是对每个三元组进行排序，然后对所有的三元组进行排序，以此找出所有的不重复的三元组。显然通过原始数组的一次排序就可以满足实现这两次排序的功能。  
排序之后，很容易想到的一种做法就是使用三重循环，每重循环分别控制abc，这样算法复杂度是O(n^3)。结合之前提到的本题的第1题的联系,对三重循环的作用进行分析，假设第一重循环使用i从0到nums.size()-3进行循环，第二三重循环分别使用jk来作为迭代器，容易看到后两重循环的作用是在数列的i+1到nums.size()-1位置找到两个数的和为i位置的数的相反数，也就是在**一段数列上找到和为固定值的两个数**。  
考虑这种场景，现在使用的O(n^2)的算法即两重循环做到的，注意现在是有序数列，简单分析可以发现，当nums[j]+nums[k]>-num[i]时，k就不需要继续向后循环了，因为之后的和总是大于-num[i]的。于是可以进行优化。其实在一段有序的数列中找到两个数的和为固定值m可以在O(n)的时间内实现，做法为: 在数列的两端分别设置left和right，然后求left和right位置的和，如果大于m，则right--；如果小于m，则left++，直到left和right相遇。  
在算法运行过程中注意控制ijk，保证求出的结果不重复，控制方法参考AC代码。其实可以看出，即使求出的结果重复也可以在求出所有的结果后很容易找出所有不重复的结果,原因是求出的三元组的有序性。  
时间复杂度: O(n^2)，排序时间复杂度为O(nlogn)，求解的时间复杂度为O(n^2)，总的时间复杂度为两者的和取最高量级。    
代码参见同文件夹solution.cpp

### 算法正确性
**正确性证明**  
本题就是简单的暴力求解加了一个小技巧，在O(n)的时间内找出和为固定值的两个数。算法的正确性等同于枚举的正确性。  
**举个例子**  

    ```
    //输入数据
    [-1,2,-1,-4]
    //排序
    [-4,-1,-1,2]
    
    //i = 0 时, j = 1, k = 3
    nums[i] = -4, target = 0 - (-4) = 4
    此时num[j] + num[k] = 1 < 4,需要增加j, j = 2
    此时num[j] + num[k] = 1 < 4,需要增加j, j = 3
    此时j !< k,需要增加i, i = 1
    //i = 1时, j = 2, k = 3
    num[i] = -1, target = 0 - (-1) = 1
    此时num[j] + num[k] = 0，得到一个结果,继续增加j，减小k, j = 3, k = 2
    此时j !< k，需要增加i,i = 2
    //i = 2时，i !< nums.size() - 2，结束运算，返回[-1, -1, 2]
    ```
