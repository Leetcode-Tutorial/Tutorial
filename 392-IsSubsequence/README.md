## 题目分析：

给我们s，t俩个字符串，问是否可以通过删除t的一些字符得到s，其实换个方法就是说，s是否是t的子串,也就是说s是否是t的一个子集.

### 解题思路（1）
采用暴力法求解，求出t的所有子集，求子集的过程中，与s进行比较，如果碰到有相等的，那么就返回`true`，如果子集都枚举完了，还没有找到与s相等的字串，就说明s不是t的字串返回`false`.但是用这种方法，子集枚举的复杂度为O(2^n),这个复杂度无论如何是不能接受的。

### 解题思路（2）：
我们可以用俩个指针i，j分别指向字符串s，t. 算法描述如下:
j指针一直往后走，碰到`t[j]==s[i]`的时候，说明匹配上了一个，将`i++`，否则i不加1，当t都走完的时候，这个时候，我们判断一下i指针是否走完了s字符串，如果走完了，说明也匹配上了，如果没有走完，那么就是没有匹配上，中间的过程，i提前等于`s.length()`的时候，也可以退出！此时的时间复杂度就是扫描一遍t，s串的线性复杂度O(`t_len`+`s_len`)，已经远远好于上面的O(2^n)

#### 算法正确性：
我们算法的关键点就在于，当`s[i]=t[j]`的时候，i和j都需要加1，那么这俩个指针加1的过程是否一定是对的呢？我们可以这样理解，当s=`"abc"`,t=`"ahbgdc"`,i=1,j=1的时候，我们只需要判断s后面的子串bc是否是t的子串hbgdc的子集（相当于分解为子问题），如果s的子串bc满足是t的子串hbgdc的子集，我们就返回true，如果不满足，我们就返回false。这样一步一步贪心下去就能保证算法正确性。

*下面举一个简单例子走一遍算法帮助理解:*
s=`"abc"`, t=`“ahbgdc”`
首先i, j都为0，分别指向s，t俩个串开头.
第一步，当`j=0`<`t_len=6`的时候，进入循环，此时`t[0]=a`,`s[0]=a`,俩者相等，那么i,j都1，此时`i=1`，`j=1`，`i!=(s_len=3)`,不跳出, j还是小于`t_len`.
此时`t[1]=h` ,`s[1]=b`,它们不相等，那么只有j加1，此时`i=1`,`j=2`，`i!=3`，不跳出.
j还是小于`t_len=6`，此时`t[2]=b`,`s[1]=b`,它们相等，那么i,j分别加1，此时`i=2`，`j=3`,`i！=3`不跳出.
那么`t[3]=g`,`s[2]=c`,它们不相等，那么之后j加1，此时`i=2`,`j=4`，`i！=3`不跳出.
此时`t[4]=d`,`s[2]=2`,它们不相等,此时j加1,`i=2`,`j=5`,`i!=3`不跳出.
j还是小于6，`t[5]=c`,`s[2]=c`,此时它们相等，`i++`，`i=3`，此时等于`s_len`，`res=true`，跳出while循环，返回结果为`true`.
