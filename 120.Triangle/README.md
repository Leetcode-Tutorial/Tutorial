### 题意
题目：三角形  
给定一个三角形，找到自顶向下的最小路径和.注意每一步只能移动到下一行的相邻的数字.  
举个例子，给定如下三角形:  
```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```
以上三角形自顶向下的最小路径和是2 + 3 +5 + 1 = 11.  
注意: 如果能在额外的O(n)空间内求解则有奖励分，这里n是三角形的行数.  

### 题解
**算法及复杂度（9 ms）**  
本题和[第64题](https://leetcode.com/problems/minimum-path-sum/#/description)类似.可以为理解全局同一限制性的寻路问题，此类问题均可使用动态规划思想求解，本文的限制是只能向下且相邻的地方移动.  
根据之前的经验，已经确定可以使用动态规划进行求解，思考如何得到动态规划方程.先使用dp[i][j]表示在从起点到三角形ij处的最小路径和，这个数值可以通过dp[i - 1][j - 1]和dp[i - 1][j]得到.具体方程为`dp[i] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]`.  
在求解过程中注意边界问题.  
如上思路进行编码即可AC本题.AC本体之后，回过头来看到题目有个提示，如果在O(n)的额外空间进行求解（以上提到的方法使用的额外空间是O(n ^ 2)）可以得到奖励分.  
观察以上方程发现，dp[i][j]的求解只与i - 1行有关，并且一行中数值的更新是同一个方向的.也就是说：可以只使用一个长度为n的数组dp[0:n]，假如本数组此时保留i-1行的数值，直接在这个数组上结合triangle第i行数值，可以在本数组上得到第i行的最小路径和.但是，如果正向更新的话，新更新的dp[j]会在j + 1后作为下一个位置的j - 1进行使用，也就是使用了更新后的值，并不是原来i - 1行的值，因此可以采用从后向前更新，这样就保证了每个求得的dp值只由上一行的dp值有关.  
**时间复杂度: ** O(n ^ 2).这里n表示三角形的行数.  
**代码参见本文件夹下solution.cpp**  

### 算法正确性
**举个例子**  
```
// 输入数据 triangle = [[-1],[-2,-3]]

// 初始化
dp[0] = triangle[0][0] = -1

// i = 1, j = i:0
dp[1] = dp[0] + triangle[1][1] = - 4
dp[0] = dp[0] + triangle[1][0] = -3

//求dp数组的最小值并返回结果
return -4
```
