### 题意
题目：最大子数列积（最大子段积）  
从一个数列中，找出一个连续子数列，要求它的乘积最大.  
举个例子:  
给定数列`[2,3,-2,4]`， 则连续子数列`[2, 3]`有最大的乘积`6`.  

### 题解
**算法及复杂度（9 ms）**  
考虑本题是最大子段的乘积，可以联想到动态规划中的一个经典问题——最大子段和.最大字段和的求解过程中，设定以位置i结尾的连续子段的最大子段和为dp[i]，那么状态转移方程为`dp[i] = dp[i - 1] > 0 ? dp[i - 1] + nums[i] : nums[i]`.  
可以看到，最大子段和问题的状态转移过程和上一个位置状态的正负有关，而在乘积问题中，仿照上述问题，设定以位置i结尾的连续子段的最大子段积为dp[i]，但是状态转移更加复杂.如果dp[i - 1] > 0，且i位置如果大于0，那个显然`dp[i] = dp[i - 1] * nums[i]`，如果i位置小于0，这个时候会发现，dp[i]的转移过程其实是和上个位置的最小值相关的，也就是应该是`dpmin[i - 1] * nums[i]`.同样的，如果dp[i-1]小于0，如果i位置小于0，dp[i]的转移过程也是和上个位置的最小值相关的.因此需要添加dpmin数组来表示以位置i结尾的连续子段的最小子段积为dpmin[i].  
重新定义一下，以位置i结尾的连续子段的最大子段积为dpmax[i]，以位置i结尾的连续子段的最小子段积为dpmin[i].那么状态转移方程容易得到:  
```
dpmax[i] = max(nums[i], max(dpmax[i - 1] * nums[i], dpmin[i - 1] * nums[i]));
dpmin[i] = min(nums[i], min(dpmax[i - 1] * nums[i], dpmin[i - 1] * nums[i]));
```
最后的结果遍历一遍dpmax就可以得到了.  

**时间复杂度:** O(n).n表示数组nums的长度.每个位置只需要遍历一次就可以得到每个位置的状态了.  
**代码参见本文件夹下solution.cpp**  

### 举例
```
// 输入数据 nums = [2,3,-2,4]

//初始化
dpmax[0] = dpmin[0] = nums[0] = 2

// i = 1
dpmax[1] = max(3, max(2 * 3, 2 * 3)) = 6
dpmin[1] = min(3, min(2 * 3, 2 * 3)) = 6

// i = 2
dpmax[2] = max(-2, max(6 * -2, 6 * -2)) = -2
dpmin[2] = min(-2, min(6 * -2, 6 * -2)) = -12

// i = 3
dpmax[3] = max(4, max(-2 * 4, -12 * 4)) = 4
dpmin[3] = min(4, min(-2 * 4, -12 * 4)) = -48

// 遍历一遍dpmax，返回最大值
return 6
```
