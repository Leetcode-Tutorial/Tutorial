### 题意
题目：路径解码  
一条包含`A - Z`字符的信息被使用如下规则进行编码：  
```  
'A' -> 1
'B' -> 2
...
'Z' -> 26
```  
给定一条编码好的数字串，确定总的解码方法数.  
举个例子，给定编码好的信息`"12"`，可以被解码为`AB"(1 2)`或者`"L"(12)`.因此，这个总的解码数量是2.  

### 题解
**算法及复杂度（0 ms）**  
本题和爬梯子（第70题）那个题有点像，仔细考虑一下看看是不是这样.  
每个英文字母最多用两个数字进行编码，也就是在解码的时候，每次使用一个数字或者两个数字进行解码.换一种说法，对前i个数字解码可以转化为：在前i-2个数字已经解码的基础上，把(i-1, i)解码成一个字母，或者在前i-1个数字已经解码的基础上，把(i)转化为一个字母.  
根据以上分析，假如把dp[i]来表示以从0到第i个数字的数字串的解码方法数，那么dp[i]可以从dp[i - 1]和dp[i - 2]得到.这个转移过程暗示动态规划过程中的最优子结构性质.  
对状态转移过程进行分析，分析状态转移过程需要满足的条件(这一部分靠细心吧)：  
```
先求出来原数字串中第i-1和第i个数字代表的真实数值，定义为value，则有

dp[i] = dp[i - 1]    0 < value < 10
dp[i] = dp[i - 2]    value = 10 or 20
dp[i] = dp[i - 1] + dp[i - 2]  10 < value < 20 or 20 < value <= 26
```  
以上过程可以自己简单画一个数轴分析一下.  
根据以上过程进行编码提交，发现发挥一个Wrong Answer，而错误的数据是`"100"`，经过分析发现，题意可能存在一点问题，本题题意是给定编码好的信息，来进行解码，所以至少存在一种解码方式，可是进行提交会发现，存在有的给定的编码好的信息的解码方式为0，也就是给定的数字串无法进行解码，与题意似乎有点矛盾.这里注意一下.  
但是为了AC掉这个题目，对自己的答案还是进行了补充，也就是，当`value % 10 == 0 && value / 10 != 1 && value / 10 != 2`时，直接返回0，经过补充之后，可以顺利进行AC.  
**时间复杂度:** O(n). n是数字串的长度，根据以上算法可以知道，数字串只需要遍历一遍即可得到结果.  
**代码参见本文件夹下solution.cpp**  

### 算法正确性
**举个例子**  
```
//输入数据，s = "101"

//初始化dp[0] = dp[1] = 1

// i = 2, value = (s[i - 2] - '0') * 10 + s[i - 1] - '0' = 10
dp[i] = dp[i - 2] = 1

// i = 3, value = (s[i - 2] - '0') * 10 + s[i - 1] - '0' = 1
dp[i] = dp[i - 1] = 1
```  
