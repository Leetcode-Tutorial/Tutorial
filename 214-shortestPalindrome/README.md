##题目分析

给出一个串，能够在串前添加字母，求出一个最短的回文串。

##题解思路

+ 一个回文串的头和尾同时往中间走，那么经历的字符应该是完全一样的。

那么再来回顾原串，我们只能往原串的头部放字母，意味着回文串的尾我们已经确定。方便起见不妨将原串逆转一下，那么题目变成往一个串后面放最少的字母构造回文串。

假设逆转后的串是s，现在我们知道了回文串的头部，知道了回文串的头部肯定也知道了回文串的尾部，因为回文串的头和尾是一样的，所以逆转s（假设是h），那么从同时从h的尾往前走和从s的头往尾走所经历的字符必须是一样的。那么如果我们发现走了k个字母后，s的后缀和h的前缀相等了，那么我们就找到了回文中心，也就是这个相等的s的后缀串（h的前缀串）的中心，因为h是s逆转来的，相当于在相等的这段后缀串中是满足上述条件的，所以只需要把不满足条件的前k个字母放到s的后面即可。

再进一步抽象，**我们需要找到一个h的一个最长的前缀，使得它等于s的后缀**。

举个例子：
假设题目给出的串是`aacecaaa`，那么`s=aaacecaa, h=aacecaaa`，我们从同时s的下标0往下走和从h的下标7往前走。我们发现取`k=1`，接下来的s的后缀`aacecaa`和h的前缀`aacecaa`是相等的，那么我们把之前路径上的字母补充到s的后面也就是s后面补充一个a，得到`ans=aaacecaaa`。

现在我们抽象出了问题，就需要用一个方案去解决了。显然这里最好的方法就是哈希，可以从s的末尾和h的首部不断通过添加字母更新哈希值，每当更新完发现了相等的两个哈希值就说明此时s的后缀等于h的前缀，便可以更新答案。最终的复杂度也不过是`O(n)`。

