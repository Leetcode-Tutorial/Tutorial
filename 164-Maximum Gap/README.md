## 题目分析：
给你一个未排序的数组，要求在线性时空复杂度内求出这个数组排好序后的相邻两个元素差的最大值，如果数组元素小于2个，返回0，数组元素全为非负数且在32位有符号整型数范围内。

### 解题思路（1）：
用常见的排序方式对数组排序，如冒泡、快排、归并等，但这些方式时间复杂度最小的也要O(nlogn)，不满足要求。

### 解题思路（2）：
使用基数排序的思想，先根据个位数的大小把所有元素分散到10个数组，然后按个位数从小到大的顺序取出这些元素并根据十位数的大小分散到10个数组，再按十位数从小到大的顺序取出这些元素并根据百位数的大小分散到10个数组，依次类推，由于32位有符号整型数最大值为2147483647，因此只需进行10次分散操作即可，然后再按照排好的顺序取相邻两个数差的最大值，复杂度满足线性要求。

#### 算法正确性：
算法的关键点在于能否保证最终得到有序序列。考虑在按十位数排列的时候，由于是按照个位数排列的顺序取出来的，因此分配到各个数组后，数组内的元素一定是按照个位有序排列的，比如说对应下标为1的数组，按十位数排列后，里面的元素一定是按后两位10、11、12…19的顺序排列，对于其它位的排列也同理，因此上述算法是正确的。

下面举一个简单例子走一遍算法帮助理解：[104,14,15,5,4]。</br>
按个位数排列：第4个数组中有[104,14,4]，第5个数组中有[15,5]；</br>
按十位数排列：第0个数组中有[104,4,5]，第1个数组中有[14,15]；</br>
按百位数排列：第0个数组中有[4,5,14,15]，第1个数组中有[104]；</br>
按千位数排列：第0个数组中有[4,5,14,15,104]；</br>
后续操作均不再发生变化，接着比较相邻两个数的差：5-4=1,14-5=9,15-14=1,104-15=89，因此最终结果为89。
