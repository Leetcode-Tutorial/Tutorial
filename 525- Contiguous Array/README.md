## 题目分析：
给定一个连续的0、1序列，要求找出满足0和1数目相同的子序列的最长长度。   
### 解题思路(1)  
使用两个指针i与j，扫描该序列。  
统计i与j指针所指出的区间内部0与1的值是否相同，若相同则查看是否能更新答案。
整体的时间复杂度为`O(N^2)`。
### 解题思路(2)
考虑[0,i]区间内0比1多出x个，[0,j]区间内0比1也多出x个`(j>i)`，则[i+1,j]区间内0与1的数目必然相等。
则目前的问题变化为，针对目前的[0,j]区间，如何去找出符合条件的[0,i]区间，并且在多个满足条件的[0,i]区间当中该如何去选择?  
易证，在满足条件的[0,i]区间之中，i越小则[i+1,j]区间越长。  
设cnt为[0,j]区间距离0与1数量相等状态的偏移量，如0比1多出一个则`cnt = -1`，0比1少一个则`cnt = 1`。  
使用`unordered_map<int, int> M`去记录偏移量为x的最前方的区间[0,i]的上界i。  
当使用指针j去扫描序列时，计算出当前的偏移量cnt，并去M中去找是否已经存储过偏移量为cnt的区间[0,i]。若存在则计算区间[i+1,j]的长度，并更新答案。否则在M[cnt]中插入j。  
对于每次HashTable的查询以及插入操作的时间复杂度为`O(1)`，至多执行N次，因此最终的时间复杂度为`O(N)`。
