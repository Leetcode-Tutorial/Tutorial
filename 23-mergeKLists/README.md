##题目分析

给定k个有序链表，求出一个合并以后的有序链表。

###题解思路（1）

先假设所有的元素个数是n。首先我们可以确定一个复杂度上界，就是把这k个链表中的所有节点保存下来排序，这样的做法复杂度主要在排序，是一个`O(nlgn)`的做法。

###题解思路（2）

接下用k个链表本身已经有序这个限制来优化下上界的算法。假设有两个来自同一个链表的元素`a,b（a<b）`，然后我们要归并到一个目标链表，那么在`a`没有被放进目标链表之前`b`肯定不会被放进目标链表。所以目标链表每次放进去的元素必然是k个链表当前表头元素中的最小值。所以我们需要维护一个数据结构，这个数据结构需要支持：

+ 能快速查找k个元素的最小值；
+ 支持插入，删除最小元素。

这些基本的操作几乎所有的平衡树都能完成。但是用平衡树解决有点大材小用了，这些要求我们可以用一个堆又快（常数小）又好（编程复杂度低）的实现，比如在C++中堆就封装成了priority_queue,可以直接拿来用。这样每次就只需在k个元素中选择一个最小值，单次是`O(lgk)`，于是我们就实现了一个`O(nlgk)`的算法，优于简单无脑的上界算法。

