##题目分析

给出一个括号串，求一个最长合法的连续括号子串。

###括号序列的性质

如果把括号序列看成一个数组，左括号当成1，右括号当成-1，`sum[0...n-1]`是这个序列的前缀和，那么他满足下面两个性质：

+ `sum[n-1]=0`
+ `min{sum[0...n-1]} >= 0`

正确性：

+ 第一点是显然的，一个合法的括号序列必然满足左括号数量等于右括号（即+1和-1的数量相等）
+ 假设`S，S'`都是一个合法括号序列，那么`(S)`和`SS'`也是合法序列，我们可以通过数学归纳法证明第二点性质：`()`显然满足第二点性质。假设`S`和`S'`满足第二点性质，那么`(S)`显然也满足（前缀和都+1，最后下标前缀和-1），`SS'`也显然满足（至少为大于等于0的前缀加上大于等于0的前缀，最终拼接的前缀序列也至少也大于等于0，并且末位仍然是0）。

###题解思路（1）

我们用`S[i...j]`表示原串中下标i到j之间的子串。那么可以通过`O(n^2)`枚举`(i,j)`，然后利用括号序列的前缀和性质`O(1)`判断`S[i...j]`，总复杂度`O(n^2)`。

###题解思路（2）

考虑到我们枚举一个下标i时，假设前缀和`sum[0...i-1]`等于pre，那么我们就相当于要在`S[i+1...n-1]`中找到一个下标j，使得`S[i...j]`满足:`sum[0...j]=pre`，`min{sum[0...k] (i<=k<=j)} >= 0`。
到目前为止，可以想到这样一种策略：枚举一个下标i，想要在`i+1~n-1`这个范围内查找一个最大的下标j满足上述条件，如果能二分那就再好不过了。
幸运的是，我们可以利用RMQ这种数据结构，通过`O(nlgn)`的预处理实现`O(1)`的区间最值查询，实现二分的策略，具体如下：二分右下标j，每次查询`sum[i...j]`中的最小值，和pre进行比较，如果比pre大（右括号太多），那么降低上界，否则提高上界，这样下来便能确定一个唯一的最远边界j。
注意到一种特殊情况，比如串`"()))))"`，当我们枚举下标i，二分右下标j时，可以发现因为此时的i-1前缀为零（边界设定），右下标最终定在了n-1，这样的一个子串显然是不合法的，这是因为我们只关注到了引理中的性质2而忽视了性质1，这种情况的实际意义**就是当我们定下了i，无论怎么二分右下标j，都可以满足引理的性质2**，此时，只需要找到一个最靠右的下标j，使得`sum[0...j]==pre`即可。我们可以通过建立一个map来映射某个值val出现的最右位置即可。
这样算法总体复杂度控制在了`O(nlgn)`,比起前面的做法已经有了很大的改进。

接下来给出两个样例：

1. ()()
  前缀和数组sum[]={1,0,1,0}。我们先定`i=0`，二分j的结果是3，发现`sum[3]==0`，说明这是一个满足两点性质的括号序列，更新`answer=4`；同理定`i=2`，二分j的结果是3，当前结果是2，不更新answer。故answer是4。
  
2. ()((
  前缀和数组sum[]={1,0,1,2}，映射数组map[2]=3,map[1]=2,map[0]=1。我们先定`i=0`，二分结果是`j=3`，发现`sum[3]!=0`，说明括号序列`S[0...3]`不满足第一点性质，于是我们就要选择一个`sum[j]=0`的最右边的j，即选择`j=map[0]`，于是我们确定了`j=1`，更新`answer=2`。接下去亦然。
  
####ps

怎样计算`S[i...j]`的前缀和呢？只需要计算出所有的`sum[0...k] (0<=k<S.length)`,那么`sum[i...j]=sum[0...j]-sum[0...i-1](注意边界)`。

